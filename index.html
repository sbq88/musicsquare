<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>çš®å¡ä¸˜çš„éŸ³ä¹ç«™</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
	  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
		-apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
	  background: radial-gradient(circle at top, #1a2a4a 0%, #050814 60%, #020308 100%);
	  color: #f7f7ff;
	  overflow-x: hidden;   /* æ¨ªå‘ä»ç„¶éšè— */
	  overflow-y: auto;     /* å…è®¸ç«–å‘æ»šåŠ¨ */
	}

    #bgCanvas {
      position: fixed;
      inset: 0;
      z-index: -1;
      background: transparent;
    }

    .main-wrapper {
      position: relative;
      z-index: 1;
      min-height: 100vh;
      padding: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card {
	  width: 100%;
	  max-width: 960px;
	  background: rgba(10, 16, 35, 0.78);
	  border-radius: 24px;
	  border: 1px solid rgba(174, 207, 255, 0.18);
	  box-shadow:
		0 18px 50px rgba(0, 0, 0, 0.65),
		0 0 0 1px rgba(255, 255, 255, 0.02);
	  backdrop-filter: blur(18px) saturate(180%);
	  padding: 20px 24px 20px;
	  display: grid;
	  grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
	  gap: 20px;
	  position: relative;
	  max-height: calc(100vh - 48px); /* ğŸ”¥ æ–°å¢ï¼šå¡ç‰‡æœ€é«˜ä¸è¶…è¿‡å±å¹•é«˜åº¦ */
	  overflow: hidden;               /* å¤šä½™å†…å®¹äº¤ç»™å†…éƒ¨å—æ¥æ»šåŠ¨ */
	}

    .floating-animal {
      position: absolute;
      font-size: 32px;
      opacity: 0.45;
      animation: float 8s ease-in-out infinite alternate;
      pointer-events: none;
    }
    .floating-animal.mouse {
      top: 10px;
      right: 12px;
      animation-delay: -1s;
    }
    .floating-animal.bolt {
      bottom: 12px;
      left: 24px;
      animation-delay: -2.5s;
    }
    .floating-animal.star {
      bottom: 50%;
      right: 40%;
      font-size: 28px;
      animation-delay: -4s;
    }

    @keyframes float {
      0% { transform: translateY(0) translateX(0) rotate(0deg); }
      100% { transform: translateY(-10px) translateX(5px) rotate(6deg); }
    }

    .card-left,
    .card-right { min-width: 0; }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }

    .logo-badge {
      width: 42px;
      height: 42px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 20%, #ffeaa7, #fdcb6e);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 25px rgba(253, 203, 110, 0.7);
      font-size: 24px;
      flex-shrink: 0;
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title-wrap h1 {
      font-size: 18px;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .title-wrap h1 span.accent {
      font-size: 20px;
      background: linear-gradient(120deg, #ffeaa7, #fdcb6e, #74b9ff);
      -webkit-background-clip: text;
      color: transparent;
      font-weight: 600;
    }

    .title-sub {
      font-size: 12px;
      color: rgba(220, 230, 255, 0.8);
    }

    .header-right {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .lang-toggle {
      font-size: 11px;
      padding: 4px 10px;
      background: rgba(9, 14, 30, 0.9);
    }

    .author-line {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
    }

    .search-bar {
      margin-top: 10px;
      margin-bottom: 8px;
      display: flex;
      gap: 10px;
    }

    .search-input-wrap {
      flex: 1;
      position: relative;
    }

    .search-input-wrap::before {
      content: "ğŸ”";
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
      opacity: 0.8;
    }

    #searchInput {
      width: 100%;
      padding: 9px 10px 9px 32px;
      border-radius: 999px;
      border: 1px solid rgba(174, 207, 255, 0.5);
      background: rgba(7, 12, 30, 0.9);
      color: #f9fbff;
      outline: none;
      font-size: 13px;
      transition: border-color 0.2s, box-shadow 0.2s, background 0.2s;
    }

    #searchInput::placeholder {
      color: rgba(200, 214, 255, 0.6);
    }

    #searchInput:focus {
      border-color: #74b9ff;
      box-shadow: 0 0 0 1px rgba(116, 185, 255, 0.4);
      background: rgba(8, 13, 35, 0.98);
    }

    #searchBtn {
      border-radius: 999px;
      border: none;
      padding: 9px 16px;
      font-size: 13px;
      cursor: pointer;
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
      color: #1a1a1a;
      font-weight: 500;
      box-shadow:
        0 0 15px rgba(253, 203, 110, 0.45),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      transition: transform 0.12s ease-out, box-shadow 0.15s ease-out;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    #searchBtn:hover {
      transform: translateY(-1px);
      box-shadow:
        0 0 18px rgba(253, 203, 110, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .source-summary-line {
      font-size: 11px;
      color: rgba(190, 205, 245, 0.95);
      margin-bottom: 6px;
      opacity: 0.9;
    }

    .results {
      background: radial-gradient(circle at top left, rgba(46, 134, 222, 0.15), transparent 50%);
      border-radius: 16px;
      padding: 10px;
      border: 1px solid rgba(116, 185, 255, 0.18);
      max-height: 330px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(116, 185, 255, 0.6) transparent;
    }

    .results::-webkit-scrollbar { width: 6px; }
    .results::-webkit-scrollbar-thumb {
      background: rgba(116, 185, 255, 0.55);
      border-radius: 999px;
    }

    .result-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 13px;
      color: rgba(232, 237, 255, 0.96);
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .result-item + .result-item { margin-top: 2px; }

    .result-item:hover {
      background: rgba(9, 17, 43, 0.95);
      transform: translateY(-1px);
    }

    .result-item.active {
      background: linear-gradient(120deg, rgba(253, 203, 110, 0.9), rgba(116, 185, 255, 0.7));
      color: #1b1b1b;
    }

    .result-main {
      display: flex;
      align-items: baseline;
      gap: 6px;
      overflow: hidden;
      flex: 1;
    }
    .result-index {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
      min-width: 22px;
      text-align: right;
    }
    .result-title {
      font-weight: 500;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 180px;
    }
    .result-singer {
      font-size: 12px;
      color: rgba(180, 196, 255, 0.9);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 110px;
    }

    .source-chip {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(12, 20, 50, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 4px;
      flex-shrink: 0;
    }
    .source-chip-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      display: inline-block;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.7);
    }
    .source-chip-migu .source-chip-dot {
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
    }
    .source-chip-netease .source-chip-dot {
      background: linear-gradient(135deg, #ff7675, #d63031);
    }

    .result-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .pill-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(12, 20, 50, 0.8);
      padding: 3px 10px;
      font-size: 11px;
      cursor: pointer;
      color: rgba(240, 245, 255, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.15s, border-color 0.15s, transform 0.1s;
    }

    .pill-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-0.5px);
    }

    .now-playing-card {
	  background: radial-gradient(circle at bottom right, rgba(255, 234, 167, 0.18), rgba(52, 73, 94, 0.7));
	  border-radius: 18px;
	  padding: 10px 12px 12px;
	  border: 1px solid rgba(255, 234, 167, 0.35);
	  display: flex;
	  flex-direction: column;
	  gap: 8px;
	  height: 100%;
	  overflow: hidden; /* ğŸ”¥ é˜²æ­¢å³ä¾§è¿™å—å†å¾€å¤–æ’‘ */
	}

    .now-playing-top {
      display: flex;
      gap: 10px;
    }

    .cover-wrap {
      width: 84px;
      height: 84px;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(8, 13, 28, 0.8);
      border: 1px solid rgba(174, 207, 255, 0.5);
      position: relative;
      flex-shrink: 0;
    }

    #coverImg {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .cover-overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.28), transparent 55%);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .song-meta {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      min-width: 0;
    }

    .song-title {
      font-size: 15px;
      font-weight: 600;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .song-singer {
      font-size: 12px;
      color: rgba(229, 233, 255, 0.9);
    }

    .song-extra {
      font-size: 11px;
      color: rgba(204, 216, 255, 0.9);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .song-extra .tag {
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(11, 19, 45, 0.85);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .tag.source-tag {
      border-color: rgba(116, 185, 255, 0.6);
      background: rgba(14, 25, 60, 0.9);
    }

    .source-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 2px;
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.65);
    }
    .source-migu {
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
    }
    .source-netease {
      background: linear-gradient(135deg, #ff7675, #d63031);
    }
    .source-mixed {
      background: linear-gradient(135deg, #fdcb6e, #ff7675);
    }

    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #audioEl { width: 100%; }

    .player-buttons {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .left-buttons,
    .right-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .link-btn {
      font-size: 11px;
      border-radius: 999px;
      padding: 4px 9px;
      border: none;
      cursor: pointer;
      background: rgba(9, 14, 30, 0.95);
      color: rgba(235, 241, 255, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      text-decoration: none;
      transition: background 0.15s, transform 0.1s;
    }

    .link-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-0.5px);
    }

    .link-btn.primary {
      background: linear-gradient(120deg, #fdcb6e, #ffeaa7);
      color: #1b1b1b;
    }

    .link-btn.primary:hover {
      background: linear-gradient(120deg, #ffeaa7, #ffeaa7);
    }

    #vizCanvas {
      width: 100%;
      height: 70px;
      border-radius: 10px;
      margin-top: 4px;
      background: rgba(5, 9, 22, 0.95);
      border: 1px solid rgba(174, 207, 255, 0.22);
    }

    .playlist-wrap {
	  margin-top: 6px;
	  background: rgba(5, 9, 22, 0.8);
	  border-radius: 12px;
	  border: 1px solid rgba(174, 207, 255, 0.18);
	  padding: 6px 8px;
	  max-height: 110px;
	  overflow-y: auto;
	  flex: 0 0 auto; /* ğŸ”¥ å›ºå®šé«˜åº¦ï¼Œä¸å‚ä¸â€œä¼¸ç¼©â€äº‰æŠ¢ç©ºé—´ */
	}

    .playlist-header {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.95);
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .playlist-header span.right {
      font-size: 10px;
      color: rgba(180, 195, 238, 0.95);
    }

    .playlist-list { max-height: 80px; }

    .playlist-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 2px 3px;
      border-radius: 8px;
      font-size: 11px;
      color: rgba(225, 235, 255, 0.95);
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .playlist-item + .playlist-item { margin-top: 2px; }

    .playlist-item:hover {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-0.5px);
    }

    .playlist-item.active {
      background: linear-gradient(120deg, rgba(253, 203, 110, 0.9), rgba(116, 185, 255, 0.7));
      color: #1b1b1b;
    }

    .playlist-index {
      min-width: 18px;
      text-align: right;
      margin-right: 4px;
    }

    .playlist-main {
      flex: 1;
      overflow: hidden;
    }

    .playlist-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .playlist-singer {
      font-size: 10px;
      opacity: 0.9;
    }

    .playlist-badge {
      font-size: 10px;
      margin-left: 4px;
      opacity: 0.85;
    }

    /* æ­Œè¯åŒºå›ºå®šé«˜åº¦ï¼Œé˜²æ­¢æŒ¤å˜å½¢ */
    .lyrics-wrap {
	  flex: 1;
	  background: rgba(7, 11, 28, 0.9);
	  border-radius: 14px;
	  padding: 8px 10px;
	  border: 1px solid rgba(174, 207, 255, 0.18);
	  overflow-y: auto;
	  max-height: 150px;
	  scrollbar-width: thin;
	  scrollbar-color: rgba(116, 185, 255, 0.7) transparent;
	  font-size: 12px;
	  margin-top: 6px;
	}

    .lyrics-wrap::-webkit-scrollbar { width: 6px; }
    .lyrics-wrap::-webkit-scrollbar-thumb {
      background: rgba(116, 185, 255, 0.7);
      border-radius: 999px;
    }

    .lyrics-placeholder {
      color: rgba(160, 177, 225, 0.9);
      text-align: center;
      padding: 14px 6px;
      white-space: pre-line;
    }

    .lyric-line {
      padding: 2px 0;
      line-height: 1.5;
      color: rgba(230, 237, 255, 0.9);
      transition: color 0.15s, transform 0.12s;
    }

    .lyric-line.active {
      color: #ffeaa7;
      font-weight: 600;
      transform: scale(1.02);
      text-shadow: 0 0 12px rgba(255, 234, 167, 0.9);
    }

    .lyrics-link-wrap {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
    }

    .status-text {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(175, 191, 238, 0.95);
    }

    .status-text span { color: #ffeaa7; }

    .shortcuts-hint {
      margin-top: 2px;
      font-size: 10px;
      color: rgba(190, 205, 245, 0.9);
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .card {
        grid-template-columns: 1fr;
        padding: 16px;
      }
      .results { max-height: 200px; }
      .now-playing-card { max-height: none; }
      #vizCanvas { height: 60px; }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>

  <div class="main-wrapper">
    <div class="card">
      <div class="floating-animal mouse">ğŸ­</div>
      <div class="floating-animal bolt">âš¡</div>
      <div class="floating-animal star">â­</div>

      <!-- å·¦ä¾§ -->
      <div class="card-left">
        <header class="header">
          <div class="logo-badge">âš¡</div>
          <div class="title-wrap">
            <h1>
              <span class="accent" id="appTitle">çš®å¡ä¸˜çš„éŸ³ä¹ç«™</span>
            </h1>
            <div class="title-sub" id="appSubtitle">
              æœç´¢ Â· æ’­æ”¾ Â· è·Ÿç€å°çš®å¡ä¸€èµ·æ‘‡å¤´
            </div>
          </div>
          <div class="header-right">
            <button id="langToggleBtn" type="button" class="pill-btn lang-toggle">
              ä¸­ / EN
            </button>
            <div id="authorLine" class="author-line">
              ä½œè€…ï¼šZhenchao Jin + GPT5
            </div>
          </div>
        </header>

        <form id="searchForm" class="search-bar">
          <div class="search-input-wrap">
            <input
              id="searchInput"
              type="text"
              autocomplete="off"
              placeholder="è¾“å…¥æ­Œå / æ­Œæ‰‹ï¼Œæ¯”å¦‚ï¼šå‘¨æ°ä¼¦"
            />
          </div>
          <button id="searchBtn" type="submit">
            æœç´¢ä¸€ä¸‹
            <span>âš¡</span>
          </button>
        </form>

        <div id="sourceSummary" class="source-summary-line">
          å½“å‰æ¥æºï¼šå’ªå’•éŸ³ä¹ + ç½‘æ˜“äº‘éŸ³ä¹
        </div>

        <div id="results" class="results"></div>
      </div>

      <!-- å³ä¾§ -->
      <div class="card-right">
        <div class="now-playing-card">
          <div class="now-playing-top">
            <div class="cover-wrap">
              <img
                id="coverImg"
                src="https://picsum.photos/seed/pikachu-music/300/300"
                alt="ä¸“è¾‘å°é¢"
              />
              <div class="cover-overlay"></div>
            </div>
            <div class="song-meta">
              <div id="songTitle" class="song-title"></div>
              <div id="songSinger" class="song-singer"></div>
              <div class="song-extra">
                <span class="tag status-tag">
                  <span>âš¡</span>
                  <span id="songStatusShort">é—²ç½®ä¸­</span>
                </span>
                <span class="tag source-tag" id="songSourceTag">
                  <span class="source-dot source-migu"></span>
                  <span id="songSourceText">MiGu</span>
                </span>
				<span class="tag source-tag" id="songSourceTag">
                  <span class="source-dot source-netease"></span>
                  <span id="songSourceText">NetEase</span>
                </span>
              </div>
            </div>
          </div>

          <div class="player-controls">
            <audio id="audioEl" controls preload="none"></audio>
            <div class="player-buttons">
              <div class="left-buttons">
                <button id="toggleLyricsBtn" type="button" class="link-btn">
                  ğŸ¼ æ˜¾ç¤º/éšè—æ­Œè¯
                </button>
              </div>
              <div class="right-buttons">
                <a id="downloadMusicBtn" href="#" class="link-btn primary" download>
                  â¬‡ï¸ ä¸‹è½½éŸ³ä¹
                </a>
                <a id="openOriginBtn" href="#" class="link-btn" target="_blank" rel="noopener">
                  ğŸŒ æ‰“å¼€åŸé“¾æ¥
                </a>
              </div>
            </div>
          </div>

          <canvas id="vizCanvas"></canvas>

          <div class="playlist-wrap">
            <div class="playlist-header">
              <span id="playlistTitle">æ’­æ”¾åˆ—è¡¨</span>
              <span class="right" id="playlistCount">ç©ºç©ºå¦‚ä¹Ÿ</span>
            </div>
            <div id="playlistList" class="playlist-list"></div>
          </div>

          <div id="lyricsWrap" class="lyrics-wrap"></div>
          <div id="lyricsLinkWrap" class="lyrics-link-wrap"></div>

          <div class="status-text">
            <span id="globalStatusText">ç­‰å¾…æœç´¢...</span>
          </div>
          <div id="shortcutsHint" class="shortcuts-hint"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // èƒŒæ™¯ç²’å­
  (function () {
    const canvas = document.getElementById("bgCanvas");
    const ctx = canvas.getContext("2d");
    let particles = [];
    const PARTICLE_COUNT = 650;
    const COLORS = [
      "rgba(255,234,167,0.9)",
      "rgba(253,203,110,0.9)",
      "rgba(116,185,255,0.85)",
      "rgba(162,155,254,0.9)"
    ];
    let shapeMode = "scatter";
    const shapeNames = ["smile", "mouse", "star"];
    let shapeIndex = 0;
    const shapeCache = {};
    let lastTimestamp = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (!particles.length) {
        createParticles();
      } else {
        particles.forEach((p) => {
          p.x = Math.random() * canvas.width;
          p.y = Math.random() * canvas.height;
          p.targetX = p.x;
          p.targetY = p.y;
        });
      }
      buildShapes();
    }

    function createParticles() {
      particles = [];
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: 0,
          vy: 0,
          size: 1.4 + Math.random() * 2.0,
          color: COLORS[Math.floor(Math.random() * COLORS.length)],
          targetX: Math.random() * canvas.width,
          targetY: Math.random() * canvas.height
        });
      }
    }

    function generateShapePoints(char) {
      const off = document.createElement("canvas");
      const w = 180;
      const h = 180;
      off.width = w;
      off.height = h;
      const octx = off.getContext("2d");
      octx.clearRect(0, 0, w, h);
      octx.fillStyle = "#fff";
      octx.textAlign = "center";
      octx.textBaseline = "middle";
      octx.font = "160px system-ui, Apple Color Emoji, Segoe UI Emoji";
      octx.fillText(char, w / 2, h / 2);

      const imgData = octx.getImageData(0, 0, w, h).data;
      const pts = [];
      const gap = 4;
      const scale = (Math.min(canvas.width, canvas.height) / w) * 0.6;

      for (let y = 0; y < h; y += gap) {
        for (let x = 0; x < w; x += gap) {
          const idx = (y * w + x) * 4 + 3;
          const alpha = imgData[idx];
          if (alpha > 50) {
            const cx = canvas.width / 2 + (x - w / 2) * scale;
            const cy = canvas.height / 2 + (y - h / 2) * scale;
            pts.push({ x: cx, y: cy });
          }
        }
      }
      return pts;
    }

    function buildShapes() {
      shapeCache["smile"] = generateShapePoints("ğŸ˜Š");
      shapeCache["mouse"] = generateShapePoints("ğŸ­");
      shapeCache["star"] = generateShapePoints("â­");
    }

    function scatterTargets() {
      particles.forEach((p) => {
        p.targetX = Math.random() * canvas.width;
        p.targetY = Math.random() * canvas.height;
      });
    }

    function applyShapeTargets(name) {
      const pts = shapeCache[name];
      if (!pts || !pts.length) return;
      particles.forEach((p, i) => {
        const pt = pts[i % pts.length];
        p.targetX = pt.x + (Math.random() - 0.5) * 10;
        p.targetY = pt.y + (Math.random() - 0.5) * 10;
      });
    }

    function animate(ts) {
      requestAnimationFrame(animate);
      const dt = ts - lastTimestamp;
      lastTimestamp = ts;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (Math.random() < 0.003 && shapeMode === "shape") {
        particles.forEach((p) => {
          p.targetX += (Math.random() - 0.5) * 6;
          p.targetY += (Math.random() - 0.5) * 6;
        });
      }

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const spring = 0.035;
        const friction = 0.9;
        const dx = p.targetX - p.x;
        const dy = p.targetY - p.y;
        p.vx += dx * spring;
        p.vy += dy * spring;
        p.vx *= friction;
        p.vy *= friction;
        p.x += p.vx * (dt / 16.7);
        p.y += p.vy * (dt / 16.7);

        if (p.x < -50 || p.x > canvas.width + 50) {
          p.x = Math.random() * canvas.width;
          p.targetX = p.x;
        }
        if (p.y < -50 || p.y > canvas.height + 50) {
          p.y = Math.random() * canvas.height;
          p.targetY = p.y;
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();

        for (let j = i + 1; j < i + 18 && j < particles.length; j++) {
          const p2 = particles[j];
          const dx2 = p2.x - p.x;
          const dy2 = p2.y - p.y;
          const dist2 = dx2 * dx2 + dy2 * dy2;
          if (dist2 < 120 * 120) {
            const alpha = 1 - dist2 / (120 * 120);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = "rgba(255, 234, 167," + (alpha * 0.25) + ")";
            ctx.lineWidth = 0.6;
            ctx.stroke();
          }
        }
      }
    }

    function startShapeCycle() {
      setInterval(() => {
        if (shapeMode === "scatter") {
          const name = shapeNames[shapeIndex % shapeNames.length];
          shapeIndex++;
          shapeMode = "shape";
          applyShapeTargets(name);
        } else {
          shapeMode = "scatter";
          scatterTargets();
        }
      }, 11500);
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    createParticles();
    buildShapes();
    scatterTargets();
    startShapeCycle();
    requestAnimationFrame(animate);
  })();

  // éŸ³ä¹é€»è¾‘ï¼šå’ªå’• + ç½‘æ˜“äº‘ åŒæº
  (function () {
    const API_MIGU = "https://api.cenguigui.cn/api/mg_music/";
    const API_NETEASE = "https://api.cenguigui.cn/api/music/netease/WyY_Dg.php";
    const NETEASE_LIMIT = 20;

    const searchForm = document.getElementById("searchForm");
    const searchInput = document.getElementById("searchInput");
    const resultsEl = document.getElementById("results");
    const searchBtn = document.getElementById("searchBtn");
    const sourceSummaryEl = document.getElementById("sourceSummary");

    const audioEl = document.getElementById("audioEl");
    const coverImg = document.getElementById("coverImg");
    const songTitleEl = document.getElementById("songTitle");
    const songSingerEl = document.getElementById("songSinger");
    const songStatusShort = document.getElementById("songStatusShort");
    const songSourceTag = document.getElementById("songSourceTag");
    const songSourceTextEl = document.getElementById("songSourceText");
    const globalStatusText = document.getElementById("globalStatusText");
    const lyricsWrap = document.getElementById("lyricsWrap");
    const lyricsLinkWrap = document.getElementById("lyricsLinkWrap");
    const langToggleBtn = document.getElementById("langToggleBtn");
    const toggleLyricsBtn = document.getElementById("toggleLyricsBtn");
    const downloadMusicBtn = document.getElementById("downloadMusicBtn");
    const openOriginBtn = document.getElementById("openOriginBtn");

    const appTitleEl = document.getElementById("appTitle");
    const appSubtitleEl = document.getElementById("appSubtitle");
    const authorLineEl = document.getElementById("authorLine");

    const vizCanvas = document.getElementById("vizCanvas");
    const vizCtx = vizCanvas ? vizCanvas.getContext("2d") : null;

    const playlistTitleEl = document.getElementById("playlistTitle");
    const playlistCountEl = document.getElementById("playlistCount");
    const playlistListEl = document.getElementById("playlistList");
    const shortcutsHintEl = document.getElementById("shortcutsHint");

    let currentLang = "zh";

    const langStaticTexts = {
      zh: {
        appTitle: "çš®å¡ä¸˜çš„éŸ³ä¹ç«™",
        appSubtitle: "æœç´¢ Â· æ’­æ”¾ Â· è·Ÿç€å°çš®å¡ä¸€èµ·æ‘‡å¤´",
        author: "ä½œè€…ï¼šZhenchao Jin + GPT5",
        searchPlaceholder: "è¾“å…¥æ­Œå / æ­Œæ‰‹ï¼Œæ¯”å¦‚ï¼šå‘¨æ°ä¼¦",
        searchBtn: "æœç´¢ä¸€ä¸‹",
        searchStatus: (q) => `æ­£åœ¨æœç´¢ â€œ${q}â€ ...`,
        searchResult: (n) => `æœç´¢åˆ° ${n} ä¸ªç»“æœï¼Œé€‰ä¸€é¦–æ¥å¬å§ï½`,
        searchNoResult: "æ²¡æœ‰æœç´¢åˆ°ç»“æœï¼Œæ¢ä¸ªå…³é”®è¯è¯•è¯•ï¼Ÿ",
        resultsInitialHint:
          "âš¡ å°æç¤ºï¼šå…ˆåœ¨ä¸Šé¢æœç´¢\næ¯”å¦‚è¾“å…¥ å‘¨æ°ä¼¦ï¼Œå†ç‚¹ä¸€é¦–æ­Œæ’­æ”¾ï½",
        lyricsInitialPlaceholder:
          "ğŸ¤ æ­Œè¯å°†ä¼šåœ¨è¿™é‡Œå‡ºç°ï¼Œå¹¶éšç€æ’­æ”¾è‡ªåŠ¨é«˜äº®ï½",
        lyricsLoading: "æ­£åœ¨åŠ è½½æ­Œè¯...",
        lyricsParseFail: "æ­Œè¯è§£æå¤±è´¥ï¼Œå¯èƒ½æ˜¯ç©ºæ–‡ä»¶ã€‚",
        lyricsNone: "è¿™é¦–æ­Œæš‚æ—¶æ²¡æœ‰è·å–åˆ°æ­Œè¯ï½",
        lyricsLoadFail: "æ­Œè¯åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•æˆ–ç›´æ¥æ‰“å¼€æ­Œè¯æ–‡ä»¶ã€‚",
        noResultPlaceholder:
          "æš‚æ—¶æ²¡æœ‰ç»“æœï¼Œå¯ä»¥å°è¯•æ¢ä¸ªæ­Œå / æ­Œæ‰‹å†æœä¸€æ¬¡ï½",
        statusInit: "ç­‰å¾…æœç´¢ï¼Œä½ å¯ä»¥è¯•è¯•è¾“å…¥â€œå‘¨æ°ä¼¦â€ã€‚",
        statusPlaying: (title) => `å¼€å§‹æ’­æ”¾ï¼š${title}`,
        statusSearchError: "æœç´¢æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚",
        statusSongError: "åŠ è½½æ­Œæ›²æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚",
        playBtn: "â–¶ æ’­æ”¾",
        toggleLyricsBtn: "ğŸ¼ æ˜¾ç¤º/éšè—æ­Œè¯",
        downloadBtn: "â¬‡ï¸ ä¸‹è½½éŸ³ä¹",
        openOriginBtn: "ğŸŒ æ‰“å¼€åŸé“¾æ¥",
        stateIdle: "é—²ç½®ä¸­",
        statePlaying: "æ’­æ”¾ä¸­",
        statePaused: "å·²æš‚åœ",
        stateEnded: "å·²ç»“æŸ",
        openLyricsPrefix: "å¦‚æœæ­Œè¯æ— æ³•æ­£å¸¸æ˜¾ç¤ºï¼Œå¯ä»¥æ‰“å¼€åŸå§‹æ­Œè¯æ–‡ä»¶ï¼š",
        openLyricsText: "æ‰“å¼€åŸå§‹æ­Œè¯",
        playlistTitle: "æ’­æ”¾åˆ—è¡¨",
        playlistEmpty: "ç©ºç©ºå¦‚ä¹Ÿ",
        playlistCount: (n) => `${n} é¦–`,
        shortcutsHint:
          "é”®ç›˜å¿«æ·é”®ï¼š\nSpaceï¼šæ’­æ”¾/æš‚åœ  â†/â†’ï¼šå¿«é€€/å¿«è¿›5ç§’\nâ†‘/â†“ï¼šéŸ³é‡Â±5%  Pï¼šä¸Šä¸€é¦–  Nï¼šä¸‹ä¸€é¦–",
        nowPlayingIdleTitle: "ç­‰å¾…ä½ çš„ç‚¹æ­Œ ğŸµ",
        nowPlayingIdleSinger: "å°çš®å¡è¯´ï¼šå…ˆæ¥ä¸€é¦–è¯•è¯•ï¼Ÿ",
        sourceLabelMigu: "å’ªå’•éŸ³ä¹",
        sourceLabelNetease: "ç½‘æ˜“äº‘éŸ³ä¹",
        sourceLabelBoth: (a, b) => `${a} + ${b}`,
        sourceSummaryNone: "å½“å‰æ¥æºï¼šæš‚æ— ",
        sourceSummaryMigu: (a) => `å½“å‰æ¥æºï¼š${a}`,
        sourceSummaryNetease: (b) => `å½“å‰æ¥æºï¼š${b}`,
        sourceSummaryBoth: (a, b) => `å½“å‰æ¥æºï¼š${a} + ${b}`
      },
      en: {
        appTitle: "Pikachu Music Station",
        appSubtitle: "Search Â· Play Â· Shake with Pikachu",
        author: "Author: Zhenchao Jin + GPT5",
        searchPlaceholder: "Song / artist, e.g. Jay Chou",
        searchBtn: "Search",
        searchStatus: (q) => `Searching for â€œ${q}â€ ...`,
        searchResult: (n) => `Found ${n} results. Pick one to play!`,
        searchNoResult: "No results, try another keyword?",
        resultsInitialHint:
          "âš¡ Tip: search above\nFor example, type Jay Chou and click a song to play.",
        lyricsInitialPlaceholder:
          "ğŸ¤ Lyrics here and auto-highlight with playback.",
        lyricsLoading: "Loading lyrics...",
        lyricsParseFail: "Failed to parse lyrics (file may be empty).",
        lyricsNone: "No lyrics found for this song.",
        lyricsLoadFail:
          "Failed to load lyrics. Please try again later or open the raw file.",
        noResultPlaceholder:
          "No results for now. Try a different song / artist.",
        statusInit: 'Waiting for search. Try typing "Jay Chou".',
        statusPlaying: (title) => `Now playing: ${title}`,
        statusSearchError: "Error during search, please try again later.",
        statusSongError: "Error loading song, please try again later.",
        playBtn: "â–¶ Play",
        toggleLyricsBtn: "ğŸ¼ Show / Hide Lyrics",
        downloadBtn: "â¬‡ï¸ Download",
        openOriginBtn: "ğŸŒ Source",
        stateIdle: "Idle",
        statePlaying: "Playing",
        statePaused: "Paused",
        stateEnded: "Ended",
        openLyricsPrefix:
          "If lyrics cannot be displayed, open the raw lyrics file:",
        openLyricsText: "Open raw lyrics",
        playlistTitle: "Playlist",
        playlistEmpty: "Empty",
        playlistCount: (n) => `${n} tracks`,
        shortcutsHint:
          "Keyboard shortcuts:\nSpace: play/pause  â†/â†’: -/+5s\nâ†‘/â†“: volume Â±5%  P: prev  N: next",
        nowPlayingIdleTitle: "Waiting for your song ğŸµ",
        nowPlayingIdleSinger: "Pikachu says: pick something to play!",
        sourceLabelMigu: "MiGu Music",
        sourceLabelNetease: "NetEase Cloud",
        sourceLabelBoth: (a, b) => `${a} + ${b}`,
        sourceSummaryNone: "Sources: none",
        sourceSummaryMigu: (a) => `Sources: ${a}`,
        sourceSummaryNetease: (b) => `Sources: ${b}`,
        sourceSummaryBoth: (a, b) => `Sources: ${a} + ${b}`
      }
    };

    let lastQuery = "";
    let lrcEntries = [];
    let currentLyricIndex = -1;
    let lyricsVisible = true;

    let playlist = [];
    let currentPlaylistPos = -1;

    let currentSongData = null;
    let currentSourceType = null;

    let lastSearchSources = { hasMigu: true, hasNetease: true };

    let vizAnimationId = null;
    if (vizCanvas && vizCtx) {
      const rect = vizCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      vizCanvas.width = rect.width * dpr;
      vizCanvas.height = rect.height * dpr;
      vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      startFakeVisualizer();
    }

    window.addEventListener("resize", () => {
      if (!vizCanvas || !vizCtx) return;
      const rect = vizCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      vizCanvas.width = rect.width * dpr;
      vizCanvas.height = rect.height * dpr;
      vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });

    function startFakeVisualizer() {
      if (!vizCanvas || !vizCtx) return;
      if (vizAnimationId) cancelAnimationFrame(vizAnimationId);

      let phase = 0;
      function draw() {
        vizAnimationId = requestAnimationFrame(draw);
        const rect = vizCanvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        if (
          vizCanvas.width !== rect.width * dpr ||
          vizCanvas.height !== rect.height * dpr
        ) {
          vizCanvas.width = rect.width * dpr;
          vizCanvas.height = rect.height * dpr;
          vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        const width = rect.width;
        const height = rect.height;
        vizCtx.clearRect(0, 0, width, height);

        const barCount = 40;
        const barWidth = width / barCount;
        const playing =
          !audioEl.paused && !audioEl.ended && audioEl.currentTime > 0;
        phase += playing ? 0.12 : 0.02;
        const base = playing ? 0.2 : 0.05;

        for (let i = 0; i < barCount; i++) {
          const wave = (Math.sin(phase + i * 0.4) + 1) / 2;
          const noise = Math.random() * 0.4;
          const v = base + (playing ? wave * 0.5 + noise * 0.2 : wave * 0.1);
          const barHeight = v * height;
          const x = i * barWidth;
          const y = height - barHeight;
          const alpha = 0.3 + 0.7 * v;

          vizCtx.fillStyle = "rgba(255,234,167," + alpha + ")";
          if (vizCtx.roundRect) {
            vizCtx.beginPath();
            vizCtx.roundRect(x + 1, y, barWidth - 2, barHeight, 4);
            vizCtx.fill();
          } else {
            vizCtx.fillRect(x + 1, y, barWidth - 2, barHeight);
          }
        }
      }
      draw();
    }

    function setStatus(text, kind) {
      globalStatusText.textContent = text;
      if (kind) globalStatusText.dataset.kind = kind;
    }

    function renderInitialResultsHint() {
      resultsEl.innerHTML = "";
      const hint = langStaticTexts[currentLang].resultsInitialHint;
      const div = document.createElement("div");
      div.className = "lyrics-placeholder";
      div.innerHTML = hint.replace(/\n/g, "<br/>");
      resultsEl.appendChild(div);
    }

    function showLyricsPlaceholder(text) {
      lyricsWrap.innerHTML = "";
      const div = document.createElement("div");
      div.className = "lyrics-placeholder";
      div.textContent = text;
      lyricsWrap.appendChild(div);
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    function showRawLyricsLink(url) {
      if (!lyricsLinkWrap) return;
      const t = langStaticTexts[currentLang];
      lyricsLinkWrap.innerHTML = "";
      const info = document.createElement("span");
      info.textContent = t.openLyricsPrefix;
      const link = document.createElement("a");
      link.href = url;
      link.target = "_blank";
      link.rel = "noopener";
      link.style.marginLeft = "4px";
      link.style.color = "#74b9ff";
      link.style.textDecoration = "underline";
      link.textContent = t.openLyricsText;
      lyricsLinkWrap.appendChild(info);
      lyricsLinkWrap.appendChild(link);
    }

    function updateSourceSummary(hasMigu, hasNetease) {
      const t = langStaticTexts[currentLang];
      let text;
      if (hasMigu && hasNetease) {
        text = t.sourceSummaryBoth(t.sourceLabelMigu, t.sourceLabelNetease);
      } else if (hasMigu) {
        text = t.sourceSummaryMigu(t.sourceLabelMigu);
      } else if (hasNetease) {
        text = t.sourceSummaryNetease(t.sourceLabelNetease);
      } else {
        text = t.sourceSummaryNone;
      }
      if (sourceSummaryEl) sourceSummaryEl.textContent = text;
    }

    function applyLanguage() {
      const t = langStaticTexts[currentLang];
      appTitleEl.textContent = t.appTitle;
      appSubtitleEl.textContent = t.appSubtitle;
      authorLineEl.textContent = t.author;
      searchInput.placeholder = t.searchPlaceholder;
      searchBtn.innerHTML = t.searchBtn + "<span>âš¡</span>";
      toggleLyricsBtn.textContent = t.toggleLyricsBtn;
      downloadMusicBtn.textContent = t.downloadBtn;
      openOriginBtn.textContent = t.openOriginBtn;
      langToggleBtn.textContent = currentLang === "zh" ? "ä¸­ / EN" : "EN / ä¸­";

      if (!currentSongData) {
        songTitleEl.textContent = t.nowPlayingIdleTitle;
        songSingerEl.textContent = t.nowPlayingIdleSinger;
      }

      if (audioEl.src) {
        if (!audioEl.paused && !audioEl.ended) {
          songStatusShort.textContent = t.statePlaying;
        } else if (audioEl.ended) {
          songStatusShort.textContent = t.stateEnded;
        } else {
          songStatusShort.textContent = t.statePaused;
        }
      } else {
        songStatusShort.textContent = t.stateIdle;
      }

      playlistTitleEl.textContent = t.playlistTitle;
      playlistCountEl.textContent = playlist.length
        ? t.playlistCount(playlist.length)
        : t.playlistEmpty;

      shortcutsHintEl.innerHTML = t.shortcutsHint.replace(/\n/g, "<br/>");

      updateSourceSummary(lastSearchSources.hasMigu, lastSearchSources.hasNetease);

      if (!lrcEntries.length) {
        showLyricsPlaceholder(t.lyricsInitialPlaceholder);
      }
      if (!resultsEl.hasChildNodes()) {
        renderInitialResultsHint();
      }
      if (globalStatusText.dataset.kind === "init") {
        setStatus(t.statusInit, "init");
      }

      if (currentSourceType) {
        let labelText;
        if (currentSourceType === "netease") {
          labelText = t.sourceLabelNetease;
        } else if (currentSourceType === "both") {
          labelText = t.sourceLabelBoth(t.sourceLabelMigu, t.sourceLabelNetease);
        } else {
          labelText = t.sourceLabelMigu;
        }
        songSourceTextEl.textContent = labelText;
      }
    }

    langToggleBtn.addEventListener("click", () => {
      currentLang = currentLang === "zh" ? "en" : "zh";
      applyLanguage();
    });

    searchForm.addEventListener("submit", function (e) {
      e.preventDefault();
      const q = searchInput.value.trim();
      if (!q) return;
      lastQuery = q;
      currentLyricIndex = -1;
      lrcEntries = [];
      const t = langStaticTexts[currentLang];
      setStatus(t.searchStatus(q));
      searchSongs(q);
    });

    async function searchSongs(query) {
      const t = langStaticTexts[currentLang];
      try {
        // å’ªå’•ï¼štype=text
        const miguUrl =
          API_MIGU +
          "?msg=" +
          encodeURIComponent(query) +
          "&type=text";

        // ç½‘æ˜“äº‘ï¼štype=text
        const neteaseUrl =
          API_NETEASE +
          "?type=text&msg=" +
          encodeURIComponent(query) +
          "&num=" +
          NETEASE_LIMIT +
          "&n=";

        const [miguResp, neteaseResp] = await Promise.all([
          fetch(miguUrl),
          fetch(neteaseUrl)
        ]);

        const [miguText, neteaseText] = await Promise.all([
          miguResp.text(),
          neteaseResp.text()
        ]);

        const miguListRaw = parseSearchResultText(miguText);
        const neteaseListRaw = parseSearchResultText(neteaseText);

        lastSearchSources = {
          hasMigu: miguListRaw.length > 0,
          hasNetease: neteaseListRaw.length > 0
        };
        updateSourceSummary(lastSearchSources.hasMigu, lastSearchSources.hasNetease);

        const merged = [];
        let globalIndex = 1;

        miguListRaw.forEach((it) => {
          merged.push({
            globalIndex: globalIndex++,
            title: it.title,
            singer: it.singer,
            source: "migu",
            apiIndex: it.index
          });
        });

        neteaseListRaw.forEach((it) => {
          merged.push({
            globalIndex: globalIndex++,
            title: it.title,
            singer: it.singer,
            source: "netease",
            apiIndex: it.index
          });
        });

        renderResultList(merged, query);

        if (!merged.length) {
          setStatus(t.searchNoResult);
        } else {
          setStatus(t.searchResult(merged.length));
        }
      } catch (err) {
        console.error(err);
        renderResultList([], query);
        setStatus(t.statusSearchError);
      }
    }

    function parseSearchResultText(text) {
	  // å…¼å®¹ "1. æ­Œå -- æ­Œæ‰‹" å’Œ "1ã€æ­Œå -- æ­Œæ‰‹"
	  const lines = text
		.split("\n")
		.map((l) => l.trim())
		.filter((l) => l && /^\d+[\.\ã€]/.test(l)); // è¿™é‡Œæ”¹äº†

	  const list = [];
	  for (const line of lines) {
		const parts = line.split(" -- ");
		if (parts.length < 2) continue;
		const left = parts[0].trim();
		const singer = parts.slice(1).join(" -- ").trim();

		// è¿™é‡Œä¹Ÿè¦å…¼å®¹ "." å’Œ "ã€"
		const idxMatch = left.match(/^(\d+)[\.\ã€](.+)$/);
		if (!idxMatch) continue;

		const index = parseInt(idxMatch[1], 10);
		const title = idxMatch[2].trim();
		list.push({ index, title, singer });
	  }
	  return list;
	}

    function renderResultList(list, queryForItems) {
      const t = langStaticTexts[currentLang];
      resultsEl.innerHTML = "";
      if (!list.length) {
        const div = document.createElement("div");
        div.className = "lyrics-placeholder";
        div.textContent = t.noResultPlaceholder;
        resultsEl.appendChild(div);
        return;
      }

      list.forEach((item) => {
        const row = document.createElement("div");
        row.className = "result-item";
        row.dataset.index = String(item.globalIndex);

        const main = document.createElement("div");
        main.className = "result-main";

        const idxEl = document.createElement("div");
        idxEl.className = "result-index";
        idxEl.textContent = item.globalIndex + ".";

        const titleEl = document.createElement("div");
        titleEl.className = "result-title";
        titleEl.textContent = item.title;

        const singerEl = document.createElement("div");
        singerEl.className = "result-singer";
        singerEl.textContent = "â€” " + item.singer;

        const chip = document.createElement("span");
        const isNetease = item.source === "netease";
        chip.className =
          "source-chip " + (isNetease ? "source-chip-netease" : "source-chip-migu");
        const chipDot = document.createElement("span");
        chipDot.className = "source-chip-dot";
        const chipText = document.createElement("span");
        chipText.textContent = isNetease
          ? t.sourceLabelNetease
          : t.sourceLabelMigu;
        chip.appendChild(chipDot);
        chip.appendChild(chipText);

        main.appendChild(idxEl);
        main.appendChild(titleEl);
        main.appendChild(singerEl);
        main.appendChild(chip);

        const actions = document.createElement("div");
        actions.className = "result-actions";

        const payload = {
          query: queryForItems,
          source: item.source,
          apiIndex: item.apiIndex,
          title: item.title,
          singer: item.singer
        };

        const playBtn = document.createElement("button");
        playBtn.type = "button";
        playBtn.className = "pill-btn";
        playBtn.innerHTML = t.playBtn;
        playBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          playSong(payload, { fromSearch: true, globalIndex: item.globalIndex });
        });

        actions.appendChild(playBtn);
        row.appendChild(main);
        row.appendChild(actions);

        row.addEventListener("click", () => {
          playSong(payload, { fromSearch: true, globalIndex: item.globalIndex });
        });

        resultsEl.appendChild(row);
      });
    }

    function highlightActiveResult(globalIndex) {
      const rows = resultsEl.querySelectorAll(".result-item");
      rows.forEach((row) => {
        row.classList.toggle(
          "active",
          globalIndex != null && row.dataset.index === String(globalIndex)
        );
      });
    }

    function renderPlaylist() {
      const t = langStaticTexts[currentLang];
      playlistListEl.innerHTML = "";
      playlist.forEach((p, idx) => {
        const row = document.createElement("div");
        row.className = "playlist-item";
        if (idx === currentPlaylistPos) row.classList.add("active");

        const idxEl = document.createElement("div");
        idxEl.className = "playlist-index";
        idxEl.textContent = idx + 1;

        const main = document.createElement("div");
        main.className = "playlist-main";

        const titleEl = document.createElement("div");
        titleEl.className = "playlist-title";
        titleEl.textContent = p.title || "Unknown";

        const singerEl = document.createElement("div");
        singerEl.className = "playlist-singer";
        singerEl.textContent = p.singer || "";

        main.appendChild(titleEl);
        main.appendChild(singerEl);

        const badge = document.createElement("div");
        badge.className = "playlist-badge";
        badge.textContent = idx === currentPlaylistPos ? "â–¶" : "";

        row.appendChild(idxEl);
        row.appendChild(main);
        row.appendChild(badge);

        row.addEventListener("click", () => {
          playFromPlaylist(idx);
        });

        playlistListEl.appendChild(row);
      });

      playlistCountEl.textContent = playlist.length
        ? t.playlistCount(playlist.length)
        : t.playlistEmpty;
    }

    async function fetchSongDetail(item) {
      if (item.source === "netease") {
        const url =
          API_NETEASE +
          "?type=json&br=4&msg=" +
          encodeURIComponent(item.query) +
          "&num=" +
          NETEASE_LIMIT +
          "&n=" +
          item.apiIndex;
        const resp = await fetch(url);
        const json = await resp.json();
        if (json.code !== 200 || !json.data) {
          throw new Error(json.msg || "Netease error");
        }
        const data = json.data;
        data._source = "netease";
        return data;
      } else {
        const url =
          API_MIGU +
          "?msg=" +
          encodeURIComponent(item.query) +
          "&type=json&n=" +
          item.apiIndex;
        const resp = await fetch(url);
        const json = await resp.json();
        if (json.code !== 200 || !json.data) {
          throw new Error(json.msg || "Migu error");
        }
        const data = json.data;
        data._source = "migu";
        return data;
      }
    }

    async function playSong(item, options) {
      const opts = options || {};
      const t = langStaticTexts[currentLang];
      lastQuery = item.query;

      let pos = playlist.findIndex(
        (p) =>
          p.query === item.query &&
          p.apiIndex === item.apiIndex &&
          p.source === item.source
      );
      if (pos === -1) {
        playlist.push(item);
        pos = playlist.length - 1;
      }
      currentPlaylistPos = pos;
      renderPlaylist();

      if (opts.fromSearch && opts.globalIndex != null) {
        highlightActiveResult(opts.globalIndex);
      }

      setStatus(t.searchStatus(item.query));
      try {
        let data = item.data;
        if (!data) {
          data = await fetchSongDetail(item);
          item.data = data;
          playlist[pos].data = data;
        }

        updateNowPlaying(data);
        setStatus(t.statusPlaying(data.title));
        audioEl.play().catch(() => {});
        await loadLyricsForData(data);
      } catch (err) {
        console.error(err);
        setStatus(t.statusSongError);
      }
    }

    function playFromPlaylist(idx) {
      if (idx < 0 || idx >= playlist.length) return;
      currentPlaylistPos = idx;
      renderPlaylist();
      const item = playlist[idx];
      playSong(item, { fromPlaylist: true });
    }

    function playNextInPlaylist() {
      if (!playlist.length) return;
      let next = currentPlaylistPos + 1;
      if (next >= playlist.length) return;
      playFromPlaylist(next);
    }

    function playPrevInPlaylist() {
      if (!playlist.length) return;
      let prev = currentPlaylistPos - 1;
      if (prev < 0) return;
      playFromPlaylist(prev);
    }

    function updateNowPlaying(data) {
      const t = langStaticTexts[currentLang];
      currentSongData = data;

      songTitleEl.textContent = data.title || t.nowPlayingIdleTitle;
      songSingerEl.textContent = data.singer || t.nowPlayingIdleSinger;

      if (!audioEl.paused && audioEl.currentTime > 0 && !audioEl.ended) {
        songStatusShort.textContent = t.statePlaying;
      } else {
        songStatusShort.textContent = t.statePlaying;
      }

      if (data.cover) coverImg.src = data.cover;

      if (data.music_url) {
        audioEl.src = data.music_url;
        downloadMusicBtn.href = data.music_url;
        downloadMusicBtn.download = (data.title || "music") + ".mp3";
      } else {
        audioEl.removeAttribute("src");
        downloadMusicBtn.href = "#";
      }

      if (data.link) openOriginBtn.href = data.link;
      else openOriginBtn.href = "#";

      const type = data._source || data.source || "migu";
      currentSourceType = type;

      let labelText = "";
      let dotClass = "source-migu";

      if (type === "netease") {
        labelText = t.sourceLabelNetease;
        dotClass = "source-netease";
      } else if (type === "both") {
        labelText = t.sourceLabelBoth(t.sourceLabelMigu, t.sourceLabelNetease);
        dotClass = "source-mixed";
      } else {
        labelText = t.sourceLabelMigu;
        dotClass = "source-migu";
      }

      songSourceTextEl.textContent = labelText;
      const dotEl = songSourceTag.querySelector(".source-dot");
      if (dotEl) dotEl.className = "source-dot " + dotClass;
      songSourceTag.style.display = "inline-flex";

      lrcEntries = [];
      currentLyricIndex = -1;
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    async function loadLyricsForData(data) {
      const t = langStaticTexts[currentLang];
      if (data.lrc_url) {
        showLyricsPlaceholder(t.lyricsLoading);
        await loadLyricsFromUrl(data.lrc_url);
      } else if (data.lrc) {
        showLyricsPlaceholder(t.lyricsLoading);
        loadLyricsFromText(data.lrc);
      } else {
        showLyricsPlaceholder(t.lyricsNone);
      }
    }

    async function loadLyricsFromUrl(url) {
      const t = langStaticTexts[currentLang];
      try {
        const resp = await fetch(url);
        const text = await resp.text();
        const entries = parseLRC(text);
        lrcEntries = entries;
        currentLyricIndex = -1;
        if (!entries.length) {
          showLyricsPlaceholder(t.lyricsParseFail);
          showRawLyricsLink(url);
          return;
        }
        renderLyrics(entries);
      } catch (err) {
        console.error(err);
        showLyricsPlaceholder(t.lyricsLoadFail);
        showRawLyricsLink(url);
      }
    }

    function loadLyricsFromText(raw) {
      const t = langStaticTexts[currentLang];
      const entries = parseLRC(raw);
      lrcEntries = entries;
      currentLyricIndex = -1;
      if (!entries.length) {
        showLyricsPlaceholder(t.lyricsParseFail);
        return;
      }
      renderLyrics(entries);
    }

    function parseLRC(raw) {
      const lines = raw.split("\n");
      const result = [];
      const timeTagRegex = /\[(\d+):(\d+(?:\.\d+)?)\]/g;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        let match;
        const timeTags = [];
        while ((match = timeTagRegex.exec(trimmed))) {
          const min = parseInt(match[1], 10);
          const sec = parseFloat(match[2]);
          const time = min * 60 + sec;
          timeTags.push(time);
        }

        const text = trimmed.replace(timeTagRegex, "").trim();
        if (!timeTags.length || !text) continue;

        timeTags.forEach((t) => {
          result.push({ time: t, text: text });
        });
      }

      result.sort((a, b) => a.time - b.time);
      return result;
    }

    function renderLyrics(entries) {
      lyricsWrap.innerHTML = "";
      entries.forEach((entry, idx) => {
        const lineEl = document.createElement("div");
        lineEl.className = "lyric-line";
        lineEl.dataset.index = String(idx);
        lineEl.dataset.time = String(entry.time);
        lineEl.textContent = entry.text;
        lyricsWrap.appendChild(lineEl);
      });
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    audioEl.addEventListener("timeupdate", () => {
      if (!lrcEntries.length) return;
      const currentTime = audioEl.currentTime;
      let idx = currentLyricIndex;
      if (idx < 0 || currentTime < lrcEntries[idx].time) idx = 0;
      while (
        idx + 1 < lrcEntries.length &&
        lrcEntries[idx + 1].time <= currentTime + 0.15
      ) {
        idx++;
      }
      if (idx !== currentLyricIndex) {
        currentLyricIndex = idx;
        updateActiveLyricLine(idx);
      }
    });

    function updateActiveLyricLine(idx) {
      const lines = lyricsWrap.querySelectorAll(".lyric-line");
      lines.forEach((el) => {
        const lineIdx = parseInt(el.dataset.index, 10);
        el.classList.toggle("active", lineIdx === idx);
      });
      const activeEl = lyricsWrap.querySelector(
        '.lyric-line[data-index="' + idx + '"]'
      );
      if (activeEl) {
        activeEl.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    audioEl.addEventListener("play", () => {
      const t = langStaticTexts[currentLang];
      songStatusShort.textContent = t.statePlaying;
    });

    audioEl.addEventListener("pause", () => {
      const t = langStaticTexts[currentLang];
      if (audioEl.ended) {
        songStatusShort.textContent = t.stateEnded;
      } else {
        songStatusShort.textContent = t.statePaused;
      }
    });

    audioEl.addEventListener("ended", () => {
      const t = langStaticTexts[currentLang];
      songStatusShort.textContent = t.stateEnded;
      playNextInPlaylist();
    });

    toggleLyricsBtn.addEventListener("click", () => {
      lyricsVisible = !lyricsVisible;
      lyricsWrap.style.display = lyricsVisible ? "block" : "none";
      if (lyricsLinkWrap)
        lyricsLinkWrap.style.display = lyricsVisible ? "block" : "none";
    });

    function togglePlayPause() {
      if (!audioEl.src) return;
      if (audioEl.paused) audioEl.play().catch(() => {});
      else audioEl.pause();
    }

    window.addEventListener("keydown", (e) => {
      const tag = (e.target.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || e.target.isContentEditable)
        return;

      if (e.code === "Space") {
        e.preventDefault();
        togglePlayPause();
      } else if (e.code === "ArrowRight") {
        if (!isNaN(audioEl.duration)) {
          audioEl.currentTime = Math.min(
            audioEl.duration,
            audioEl.currentTime + 5
          );
        }
      } else if (e.code === "ArrowLeft") {
        audioEl.currentTime = Math.max(0, audioEl.currentTime - 5);
      } else if (e.code === "ArrowUp") {
        e.preventDefault();
        audioEl.volume = Math.min(1, audioEl.volume + 0.05);
      } else if (e.code === "ArrowDown") {
        e.preventDefault();
        audioEl.volume = Math.max(0, audioEl.volume - 0.05);
      } else if (e.key === "n" || e.key === "N") {
        playNextInPlaylist();
      } else if (e.key === "p" || e.key === "P") {
        playPrevInPlaylist();
      }
    });

    // åˆå§‹çŠ¶æ€
    renderInitialResultsHint();
    showLyricsPlaceholder(langStaticTexts[currentLang].lyricsInitialPlaceholder);
    setStatus(langStaticTexts[currentLang].statusInit, "init");
    updateSourceSummary(lastSearchSources.hasMigu, lastSearchSources.hasNetease);
    applyLanguage();
  })();
  </script>
</body>
</html>
