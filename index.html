<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>ÁöÆÂç°‰∏òÁöÑÈü≥‰πêÁ´ô</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
        -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at top, #1a2a4a 0%, #050814 60%, #020308 100%);
      color: #f7f7ff;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #bgCanvas {
      position: fixed;
      inset: 0;
      z-index: -1;
      background: transparent;
    }

    .main-wrapper {
      position: relative;
      z-index: 1;
      min-height: 100vh;
      padding: 24px;
      display: flex;
      align-items: flex-start; /* È°∂ÈÉ®ÂØπÈΩêÔºåÈÅøÂÖçÊï¥‰ΩìË¢´Êå§Âá∫Â±èÂπï */
      justify-content: center;
    }

    .card {
      width: 100%;
      max-width: 960px;
      background: rgba(10, 16, 35, 0.78);
      border-radius: 24px;
      border: 1px solid rgba(174, 207, 255, 0.18);
      box-shadow:
        0 18px 50px rgba(0, 0, 0, 0.65),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(18px) saturate(180%);
      padding: 20px 24px 20px;
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
      gap: 20px;
      position: relative;
      max-height: calc(100vh - 48px);
      overflow-x: hidden;
      overflow-y: auto; /* ÂÜÖÈÉ®ÊªöÂä®ÔºåÈÅøÂÖçÂÜÖÂÆπË¢´Ë£ÅÊéâ */
    }

    .floating-animal {
      position: absolute;
      font-size: 32px;
      opacity: 0.45;
      animation: float 8s ease-in-out infinite alternate;
      pointer-events: none;
    }
    .floating-animal.mouse {
      top: 10px;
      right: 12px;
      animation-delay: -1s;
    }
    .floating-animal.bolt {
      bottom: 12px;
      left: 24px;
      animation-delay: -2.5s;
    }
    .floating-animal.star {
      bottom: 50%;
      right: 40%;
      font-size: 28px;
      animation-delay: -4s;
    }

    @keyframes float {
      0% { transform: translateY(0) translateX(0) rotate(0deg); }
      100% { transform: translateY(-10px) translateX(5px) rotate(6deg); }
    }

    .card-left,
    .card-right { min-width: 0; }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }

    .logo-badge {
      width: 42px;
      height: 42px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 20%, #ffeaa7, #fdcb6e);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 25px rgba(253, 203, 110, 0.7);
      font-size: 24px;
      flex-shrink: 0;
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title-wrap h1 {
      font-size: 18px;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .title-wrap h1 span.accent {
      font-size: 20px;
      background: linear-gradient(120deg, #ffeaa7, #fdcb6e, #74b9ff);
      -webkit-background-clip: text;
      color: transparent;
      font-weight: 600;
    }

    .title-sub {
      font-size: 12px;
      color: rgba(220, 230, 255, 0.8);
    }

    .header-right {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .lang-toggle {
      font-size: 11px;
      padding: 4px 10px;
      background: rgba(9, 14, 30, 0.9);
    }

    .author-line {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
    }

    .search-bar {
      margin-top: 10px;
      margin-bottom: 8px;
      display: flex;
      gap: 10px;
    }

    .search-input-wrap {
      flex: 1;
      position: relative;
    }

    .search-input-wrap::before {
      content: "üîç";
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
      opacity: 0.8;
    }

    #searchInput {
      width: 100%;
      padding: 9px 10px 9px 32px;
      border-radius: 999px;
      border: 1px solid rgba(174, 207, 255, 0.5);
      background: rgba(7, 12, 30, 0.9);
      color: #f9fbff;
      outline: none;
      font-size: 13px;
      transition: border-color 0.2s, box-shadow 0.2s, background 0.2s;
    }

    #searchInput::placeholder {
      color: rgba(200, 214, 255, 0.6);
    }

    #searchInput:focus {
      border-color: #74b9ff;
      box-shadow: 0 0 0 1px rgba(116, 185, 255, 0.4);
      background: rgba(8, 13, 35, 0.98);
    }

    #searchBtn {
      border-radius: 999px;
      border: none;
      padding: 9px 16px;
      font-size: 13px;
      cursor: pointer;
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
      color: #1a1a1a;
      font-weight: 500;
      box-shadow:
        0 0 15px rgba(253, 203, 110, 0.45),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      transition: transform 0.12s ease-out, box-shadow 0.15s ease-out;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    #searchBtn:hover {
      transform: translateY(-1px);
      box-shadow:
        0 0 18px rgba(253, 203, 110, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .source-summary-line {
      font-size: 11px;
      color: rgba(190, 205, 245, 0.95);
      margin-bottom: 6px;
      opacity: 0.9;
    }

    /* ÊêúÁ¥¢Êù•Ê∫êÁ≠õÈÄâ */
    .source-filter {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
      margin-bottom: 4px;
      font-size: 11px;
      color: rgba(200, 214, 255, 0.95);
    }

    .source-filter-label {
      opacity: 0.9;
    }

    .source-filter-option {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(7, 12, 30, 0.9);
      border: 1px solid rgba(174, 207, 255, 0.45);
      cursor: pointer;
    }

    .source-filter-option input {
      cursor: pointer;
      accent-color: #fdcb6e;
    }

    .source-filter-option span {
      white-space: nowrap;
    }

    .results {
      background: radial-gradient(circle at top left, rgba(46, 134, 222, 0.15), transparent 50%);
      border-radius: 16px;
      padding: 10px;
      border: 1px solid rgba(116, 185, 255, 0.18);
      max-height: 330px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(116, 185, 255, 0.6) transparent;
    }

    .results::-webkit-scrollbar { width: 6px; }
    .results::-webkit-scrollbar-thumb {
      background: rgba(116, 185, 255, 0.55);
      border-radius: 999px;
    }

    .result-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 13px;
      color: rgba(232, 237, 255, 0.96);
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .result-item + .result-item { margin-top: 2px; }

    .result-item:hover {
      background: rgba(9, 17, 43, 0.95);
      transform: translateY(-1px);
    }

    .result-item.active {
      background: linear-gradient(120deg, rgba(253, 203, 110, 0.9), rgba(116, 185, 255, 0.7));
      color: #1b1b1b;
    }

    .result-main {
      display: flex;
      align-items: baseline;
      gap: 6px;
      overflow: hidden;
      flex: 1;
    }
    .result-index {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
      min-width: 22px;
      text-align: right;
    }
    .result-title {
      font-weight: 500;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 180px;
    }
    .result-singer {
      font-size: 12px;
      color: rgba(180, 196, 255, 0.9);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 110px;
    }

    .source-chip {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(12, 20, 50, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 4px;
      flex-shrink: 0;
    }
    .source-chip-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      display: inline-block;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.7);
    }
    .source-chip-migu .source-chip-dot {
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
    }
    .source-chip-netease .source-chip-dot {
      background: linear-gradient(135deg, #ff7675, #d63031);
    }

    .result-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .pill-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(12, 20, 50, 0.8);
      padding: 3px 10px;
      font-size: 11px;
      cursor: pointer;
      color: rgba(240, 245, 255, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.15s, border-color 0.15s, transform 0.1s;
    }

    .pill-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-0.5px);
    }

    .now-playing-card {
      background: radial-gradient(circle at bottom right, rgba(255, 234, 167, 0.18), rgba(52, 73, 94, 0.7));
      border-radius: 18px;
      padding: 10px 12px 12px;
      border: 1px solid rgba(255, 234, 167, 0.35);
      display: flex;
      flex-direction: column;
      gap: 8px;
      height: 100%;
      overflow: hidden;
    }

    .now-playing-top {
      display: flex;
      gap: 10px;
    }

    .cover-wrap {
      width: 84px;
      height: 84px;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(8, 13, 28, 0.8);
      border: 1px solid rgba(174, 207, 255, 0.5);
      position: relative;
      flex-shrink: 0;
    }

    #coverImg {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .cover-overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.28), transparent 55%);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .song-meta {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      min-width: 0;
    }

    .song-title {
      font-size: 15px;
      font-weight: 600;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .song-singer {
      font-size: 12px;
      color: rgba(229, 233, 255, 0.9);
    }

    .song-extra {
      font-size: 11px;
      color: rgba(204, 216, 255, 0.9);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .song-extra .tag {
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(11, 19, 45, 0.85);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .tag.source-tag {
      border-color: rgba(116, 185, 255, 0.6);
      background: rgba(14, 25, 60, 0.9);
    }

    .source-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 2px;
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.65);
    }
    .source-migu {
      background: linear-gradient(135deg, #fdcb6e, #ffeaa7);
    }
    .source-netease {
      background: linear-gradient(135deg, #ff7675, #d63031);
    }
    .source-mixed {
      background: linear-gradient(135deg, #fdcb6e, #ff7675);
    }

    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #audioEl { width: 100%; }

    .player-buttons {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .left-buttons,
    .right-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .link-btn {
      font-size: 11px;
      border-radius: 999px;
      padding: 4px 9px;
      border: none;
      cursor: pointer;
      background: rgba(9, 14, 30, 0.95);
      color: rgba(235, 241, 255, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      text-decoration: none;
      transition: background 0.15s, transform 0.1s;
    }

    .link-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-0.5px);
    }

    .link-btn.primary {
      background: linear-gradient(120deg, #fdcb6e, #ffeaa7);
      color: #1b1b1b;
    }

    .link-btn.primary:hover {
      background: linear-gradient(120deg, #ffeaa7, #ffeaa7);
    }

    #vizCanvas {
      width: 100%;
      height: 70px;
      border-radius: 10px;
      margin-top: 4px;
      background: rgba(5, 9, 22, 0.95);
      border: 1px solid rgba(174, 207, 255, 0.22);
    }

    .playlist-wrap {
      margin-top: 6px;
      background: rgba(5, 9, 22, 0.8);
      border-radius: 12px;
      border: 1px solid rgba(174, 207, 255, 0.18);
      padding: 6px 8px;
      max-height: 110px;
      overflow-y: auto;
      flex: 0 0 auto;
    }

    .playlist-header {
      font-size: 11px;
      color: rgba(200, 214, 255, 0.95);
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .playlist-header span.right {
      font-size: 10px;
      color: rgba(180, 195, 238, 0.95);
    }

    .playlist-list { max-height: 80px; }

    .playlist-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 2px 3px;
      border-radius: 8px;
      font-size: 11px;
      color: rgba(225, 235, 255, 0.95);
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }

    .playlist-item + .playlist-item { margin-top: 2px; }

    .playlist-item:hover {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-0.5px);
    }

    .playlist-item.active {
      background: linear-gradient(120deg, rgba(253, 203, 110, 0.9), rgba(116, 185, 255, 0.7));
      color: #1b1b1b;
    }

    .playlist-index {
      min-width: 18px;
      text-align: right;
      margin-right: 4px;
    }

    .playlist-main {
      flex: 1;
      overflow: hidden;
    }

    .playlist-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .playlist-singer {
      font-size: 10px;
      opacity: 0.9;
    }

    .playlist-badge {
      font-size: 10px;
      margin-left: 4px;
      opacity: 0.85;
    }

    .lyrics-wrap {
      flex: 1;
      background: rgba(7, 11, 28, 0.9);
      border-radius: 14px;
      padding: 8px 10px;
      border: 1px solid rgba(174, 207, 255, 0.18);
      overflow-y: auto;
      max-height: 100px;
      scrollbar-width: thin;
      scrollbar-color: rgba(116, 185, 255, 0.7) transparent;
      font-size: 12px;
      margin-top: 6px;
    }

    .lyrics-wrap::-webkit-scrollbar { width: 6px; }
    .lyrics-wrap::-webkit-scrollbar-thumb {
      background: rgba(116, 185, 255, 0.7);
      border-radius: 999px;
    }

    .lyrics-placeholder {
      color: rgba(160, 177, 225, 0.9);
      text-align: center;
      padding: 14px 6px;
      white-space: pre-line;
    }

    .lyric-line {
      padding: 2px 0;
      line-height: 1.5;
      color: rgba(230, 237, 255, 0.9);
      transition: color 0.15s, transform 0.12s;
    }

    .lyric-line.active {
      color: #ffeaa7;
      font-weight: 600;
      transform: scale(1.02);
      text-shadow: 0 0 12px rgba(255, 234, 167, 0.9);
    }

    .lyrics-link-wrap {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(200, 214, 255, 0.9);
    }

    .status-text {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(175, 191, 238, 0.95);
    }

    .status-text span { color: #ffeaa7; }

    .shortcuts-hint {
      margin-top: 2px;
      font-size: 10px;
      color: rgba(190, 205, 245, 0.9);
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .card {
        grid-template-columns: 1fr;
        padding: 16px;
        max-height: none;      /* Â∞èÂ±è‰∏ã‰∫§ÁªôÈ°µÈù¢Êï¥‰ΩìÊªöÂä® */
        height: auto;
        overflow-y: visible;
      }
      .results { max-height: 200px; }
      .now-playing-card { max-height: none; }
      #vizCanvas { height: 60px; }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>

  <div class="main-wrapper">
    <div class="card">
      <div class="floating-animal mouse">üê≠</div>
      <div class="floating-animal bolt">‚ö°</div>
      <div class="floating-animal star">‚≠ê</div>

      <!-- Â∑¶‰æß -->
      <div class="card-left">
        <header class="header">
          <div class="logo-badge">‚ö°</div>
          <div class="title-wrap">
            <h1>
              <span class="accent" id="appTitle">ÁöÆÂç°‰∏òÁöÑÈü≥‰πêÁ´ô</span>
            </h1>
            <div class="title-sub" id="appSubtitle">
              ÊêúÁ¥¢ ¬∑ Êí≠Êîæ ¬∑ Ë∑üÁùÄÂ∞èÁöÆÂç°‰∏ÄËµ∑ÊëáÂ§¥
            </div>
          </div>
          <div class="header-right">
            <button id="langToggleBtn" type="button" class="pill-btn lang-toggle">
              ‰∏≠ / EN
            </button>
            <div id="authorLine" class="author-line">
              ‰ΩúËÄÖÔºöZhenchao Jin + GPT5
            </div>
          </div>
        </header>

        <form id="searchForm" class="search-bar">
          <div class="search-input-wrap">
            <input
              id="searchInput"
              type="text"
              autocomplete="off"
              placeholder="ËæìÂÖ•Ê≠åÂêç / Ê≠åÊâãÔºåÊØîÂ¶ÇÔºöÂë®Êù∞‰º¶"
            />
          </div>
          <button id="searchBtn" type="submit">
            ÊêúÁ¥¢‰∏Ä‰∏ã
            <span>‚ö°</span>
          </button>
        </form>

        <!-- ÊêúÁ¥¢Êù•Ê∫êÁ≠õÈÄâ -->
        <div class="source-filter">
          <span id="sourceFilterLabel" class="source-filter-label">ÊêúÁ¥¢Êù•Ê∫êÔºö</span>
          <label class="source-filter-option">
            <input type="checkbox" id="sourceMiguCheckbox" checked />
            <span id="sourceFilterMiguText">Âí™ÂíïÈü≥‰πê</span>
          </label>
          <label class="source-filter-option">
            <input type="checkbox" id="sourceNeteaseCheckbox" checked />
            <span id="sourceFilterNeteaseText">ÁΩëÊòì‰∫ëÈü≥‰πê</span>
          </label>
        </div>

        <div id="sourceSummary" class="source-summary-line">
          ÂΩìÂâçÊù•Ê∫êÔºöÂí™ÂíïÈü≥‰πê + ÁΩëÊòì‰∫ëÈü≥‰πê
        </div>

        <div id="results" class="results"></div>
      </div>

      <!-- Âè≥‰æß -->
      <div class="card-right">
        <div class="now-playing-card">
          <div class="now-playing-top">
            <div class="cover-wrap">
              <img
                id="coverImg"
                src="https://picsum.photos/seed/pikachu-music/300/300"
                alt="‰∏ìËæëÂ∞ÅÈù¢"
              />
              <div class="cover-overlay"></div>
            </div>
            <div class="song-meta">
              <div id="songTitle" class="song-title"></div>
              <div id="songSinger" class="song-singer"></div>
              <div class="song-extra">
                <span class="tag status-tag">
                  <span>‚ö°</span>
                  <span id="songStatusShort">Èó≤ÁΩÆ‰∏≠</span>
                </span>
                <span class="tag source-tag" id="songSourceTag">
                  <span class="source-dot source-migu"></span>
                  <span id="songSourceText">MiGu</span>
                </span>
              </div>
            </div>
          </div>

          <div class="player-controls">
            <audio id="audioEl" controls preload="none"></audio>
            <div class="player-buttons">
              <div class="left-buttons">
                <button id="toggleLyricsBtn" type="button" class="link-btn">
                  üéº ÊòæÁ§∫/ÈöêËóèÊ≠åËØç
                </button>
                <!-- Êí≠ÊîæÊ®°ÂºèÊåâÈíÆ -->
                <button id="playModeBtn" type="button" class="link-btn">
                  üîÅ È°∫Â∫è
                </button>
              </div>
              <div class="right-buttons">
                <a id="downloadMusicBtn" href="#" class="link-btn primary" download>
                  ‚¨áÔ∏è ‰∏ãËΩΩÈü≥‰πê
                </a>
                <a id="openOriginBtn" href="#" class="link-btn" target="_blank" rel="noopener">
                  üåê ÊâìÂºÄÂéüÈìæÊé•
                </a>
              </div>
            </div>
          </div>

          <canvas id="vizCanvas"></canvas>

          <div class="playlist-wrap">
            <div class="playlist-header">
              <span id="playlistTitle">Êí≠ÊîæÂàóË°®</span>
              <span class="right" id="playlistCount">Á©∫Á©∫Â¶Ç‰πü</span>
            </div>
            <div id="playlistList" class="playlist-list"></div>
          </div>

          <div id="lyricsWrap" class="lyrics-wrap"></div>
          <div id="lyricsLinkWrap" class="lyrics-link-wrap"></div>

          <div class="status-text">
            <span id="globalStatusText">Á≠âÂæÖÊêúÁ¥¢...</span>
          </div>
          <div id="shortcutsHint" class="shortcuts-hint"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ËÉåÊôØÁ≤íÂ≠ê
  (function () {
    const canvas = document.getElementById("bgCanvas");
    const ctx = canvas.getContext("2d");
    let particles = [];
    const PARTICLE_COUNT = 650;
    const COLORS = [
      "rgba(255,234,167,0.9)",
      "rgba(253,203,110,0.9)",
      "rgba(116,185,255,0.85)",
      "rgba(162,155,254,0.9)"
    ];
    let shapeMode = "scatter";
    const shapeNames = ["smile", "mouse", "star"];
    let shapeIndex = 0;
    const shapeCache = {};
    let lastTimestamp = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (!particles.length) {
        createParticles();
      } else {
        particles.forEach((p) => {
          p.x = Math.random() * canvas.width;
          p.y = Math.random() * canvas.height;
          p.targetX = p.x;
          p.targetY = p.y;
        });
      }
      buildShapes();
    }

    function createParticles() {
      particles = [];
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: 0,
          vy: 0,
          size: 1.4 + Math.random() * 2.0,
          color: COLORS[Math.floor(Math.random() * COLORS.length)],
          targetX: Math.random() * canvas.width,
          targetY: Math.random() * canvas.height
        });
      }
    }

    function generateShapePoints(char) {
      const off = document.createElement("canvas");
      const w = 180;
      const h = 180;
      off.width = w;
      off.height = h;
      const octx = off.getContext("2d");
      octx.clearRect(0, 0, w, h);
      octx.fillStyle = "#fff";
      octx.textAlign = "center";
      octx.textBaseline = "middle";
      octx.font = "160px system-ui, Apple Color Emoji, Segoe UI Emoji";
      octx.fillText(char, w / 2, h / 2);

      const imgData = octx.getImageData(0, 0, w, h).data;
      const pts = [];
      const gap = 4;
      const scale = (Math.min(canvas.width, canvas.height) / w) * 0.6;

      for (let y = 0; y < h; y += gap) {
        for (let x = 0; x < w; x += gap) {
          const idx = (y * w + x) * 4 + 3;
          const alpha = imgData[idx];
          if (alpha > 50) {
            const cx = canvas.width / 2 + (x - w / 2) * scale;
            const cy = canvas.height / 2 + (y - h / 2) * scale;
            pts.push({ x: cx, y: cy });
          }
        }
      }
      return pts;
    }

    function buildShapes() {
      shapeCache["smile"] = generateShapePoints("üòä");
      shapeCache["mouse"] = generateShapePoints("üê≠");
      shapeCache["star"] = generateShapePoints("‚≠ê");
    }

    function scatterTargets() {
      particles.forEach((p) => {
        p.targetX = Math.random() * canvas.width;
        p.targetY = Math.random() * canvas.height;
      });
    }

    function applyShapeTargets(name) {
      const pts = shapeCache[name];
      if (!pts || !pts.length) return;
      particles.forEach((p, i) => {
        const pt = pts[i % pts.length];
        p.targetX = pt.x + (Math.random() - 0.5) * 10;
        p.targetY = pt.y + (Math.random() - 0.5) * 10;
      });
    }

    function animate(ts) {
      requestAnimationFrame(animate);
      const dt = ts - lastTimestamp;
      lastTimestamp = ts;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (Math.random() < 0.003 && shapeMode === "shape") {
        particles.forEach((p) => {
          p.targetX += (Math.random() - 0.5) * 6;
          p.targetY += (Math.random() - 0.5) * 6;
        });
      }

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const spring = 0.035;
        const friction = 0.9;
        const dx = p.targetX - p.x;
        const dy = p.targetY - p.y;
        p.vx += dx * spring;
        p.vy += dy * spring;
        p.vx *= friction;
        p.vy *= friction;
        p.x += p.vx * (dt / 16.7);
        p.y += p.vy * (dt / 16.7);

        if (p.x < -50 || p.x > canvas.width + 50) {
          p.x = Math.random() * canvas.width;
          p.targetX = p.x;
        }
        if (p.y < -50 || p.y > canvas.height + 50) {
          p.y = Math.random() * canvas.height;
          p.targetY = p.y;
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();

        for (let j = i + 1; j < i + 18 && j < particles.length; j++) {
          const p2 = particles[j];
          const dx2 = p2.x - p.x;
          const dy2 = p2.y - p.y;
          const dist2 = dx2 * dx2 + dy2 * dy2;
          if (dist2 < 120 * 120) {
            const alpha = 1 - dist2 / (120 * 120);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = "rgba(255, 234, 167," + (alpha * 0.25) + ")";
            ctx.lineWidth = 0.6;
            ctx.stroke();
          }
        }
      }
    }

    function startShapeCycle() {
      setInterval(() => {
        if (shapeMode === "scatter") {
          const name = shapeNames[shapeIndex % shapeNames.length];
          shapeIndex++;
          shapeMode = "shape";
          applyShapeTargets(name);
        } else {
          shapeMode = "scatter";
          scatterTargets();
        }
      }, 11500);
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    createParticles();
    buildShapes();
    scatterTargets();
    startShapeCycle();
    requestAnimationFrame(animate);
  })();

  // Èü≥‰πêÈÄªËæëÔºöÂí™Âíï + ÁΩëÊòì‰∫ë ÂèåÊ∫ê + ÊêúÁ¥¢Êù•Ê∫êÁ≠õÈÄâ
  (function () {
    const API_MIGU = "https://api.cenguigui.cn/api/mg_music/";
    const API_NETEASE_SEARCH = "https://api.cenguigui.cn/api/music/netease/WyY_Dg.php";
    const API_NETEASE_DETAIL = "https://api.cenguigui.cn/api/netease/music_v1.php";

    const NETEASE_LIMIT = 20;

    const searchForm = document.getElementById("searchForm");
    const searchInput = document.getElementById("searchInput");
    const resultsEl = document.getElementById("results");
    const searchBtn = document.getElementById("searchBtn");
    const sourceSummaryEl = document.getElementById("sourceSummary");

    const sourceMiguCheckbox = document.getElementById("sourceMiguCheckbox");
    const sourceNeteaseCheckbox = document.getElementById("sourceNeteaseCheckbox");
    const sourceFilterLabelEl = document.getElementById("sourceFilterLabel");
    const sourceFilterMiguTextEl = document.getElementById("sourceFilterMiguText");
    const sourceFilterNeteaseTextEl = document.getElementById("sourceFilterNeteaseText");

    const audioEl = document.getElementById("audioEl");
    const coverImg = document.getElementById("coverImg");
    const songTitleEl = document.getElementById("songTitle");
    const songSingerEl = document.getElementById("songSinger");
    const songStatusShort = document.getElementById("songStatusShort");
    const songSourceTag = document.getElementById("songSourceTag");
    const songSourceTextEl = document.getElementById("songSourceText");
    const globalStatusText = document.getElementById("globalStatusText");
    const lyricsWrap = document.getElementById("lyricsWrap");
    const lyricsLinkWrap = document.getElementById("lyricsLinkWrap");
    const langToggleBtn = document.getElementById("langToggleBtn");
    const toggleLyricsBtn = document.getElementById("toggleLyricsBtn");
    const playModeBtn = document.getElementById("playModeBtn");
    const downloadMusicBtn = document.getElementById("downloadMusicBtn");
    const openOriginBtn = document.getElementById("openOriginBtn");

    const appTitleEl = document.getElementById("appTitle");
    const appSubtitleEl = document.getElementById("appSubtitle");
    const authorLineEl = document.getElementById("authorLine");

    const vizCanvas = document.getElementById("vizCanvas");
    const vizCtx = vizCanvas ? vizCanvas.getContext("2d") : null;

    const playlistTitleEl = document.getElementById("playlistTitle");
    const playlistCountEl = document.getElementById("playlistCount");
    const playlistListEl = document.getElementById("playlistList");
    const shortcutsHintEl = document.getElementById("shortcutsHint");

    // Êí≠ÊîæÊ®°ÂºèÔºöÈ°∫Â∫è / ÂàóË°®Âæ™ÁéØ / ÂçïÊõ≤Âæ™ÁéØ
    const PLAY_MODE_SEQUENCE = "sequence";
    const PLAY_MODE_LOOP_ALL = "loop_all";
    const PLAY_MODE_SINGLE = "single";
    let playMode = PLAY_MODE_SEQUENCE;

    let currentLang = "zh";

    const langStaticTexts = {
      zh: {
        appTitle: "ÁöÆÂç°‰∏òÁöÑÈü≥‰πêÁ´ô",
        appSubtitle: "ÊêúÁ¥¢ ¬∑ Êí≠Êîæ ¬∑ Ë∑üÁùÄÂ∞èÁöÆÂç°‰∏ÄËµ∑ÊëáÂ§¥",
        author: "‰ΩúËÄÖÔºöZhenchao Jin + GPT5",
        searchPlaceholder: "ËæìÂÖ•Ê≠åÂêç / Ê≠åÊâãÔºåÊØîÂ¶ÇÔºöÂë®Êù∞‰º¶",
        searchBtn: "ÊêúÁ¥¢‰∏Ä‰∏ã",
        searchStatus: (q) => `Ê≠£Âú®ÊêúÁ¥¢ ‚Äú${q}‚Äù ...`,
        searchResult: (n) => `ÊêúÁ¥¢Âà∞ ${n} ‰∏™ÁªìÊûúÔºåÈÄâ‰∏ÄÈ¶ñÊù•Âê¨ÂêßÔΩû`,
        searchNoResult: "Ê≤°ÊúâÊêúÁ¥¢Âà∞ÁªìÊûúÔºåÊç¢‰∏™ÂÖ≥ÈîÆËØçËØïËØïÔºü",
        resultsInitialHint:
          "‚ö° Â∞èÊèêÁ§∫ÔºöÂÖàÂú®‰∏äÈù¢ÊêúÁ¥¢\nÊØîÂ¶ÇËæìÂÖ• Âë®Êù∞‰º¶ÔºåÂÜçÁÇπ‰∏ÄÈ¶ñÊ≠åÊí≠ÊîæÔΩû",
        lyricsInitialPlaceholder:
          "üé§ Ê≠åËØçÂ∞Ü‰ºöÂú®ËøôÈáåÂá∫Áé∞ÔºåÂπ∂ÈöèÁùÄÊí≠ÊîæËá™Âä®È´ò‰∫ÆÔΩû",
        lyricsLoading: "Ê≠£Âú®Âä†ËΩΩÊ≠åËØç...",
        lyricsParseFail: "Ê≠åËØçËß£ÊûêÂ§±Ë¥•ÔºåÂèØËÉΩÊòØÁ©∫Êñá‰ª∂„ÄÇ",
        lyricsNone: "ËøôÈ¶ñÊ≠åÊöÇÊó∂Ê≤°ÊúâËé∑ÂèñÂà∞Ê≠åËØçÔΩû",
        lyricsLoadFail: "Ê≠åËØçÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØïÊàñÁõ¥Êé•ÊâìÂºÄÊ≠åËØçÊñá‰ª∂„ÄÇ",
        noResultPlaceholder:
          "ÊöÇÊó∂Ê≤°ÊúâÁªìÊûúÔºåÂèØ‰ª•Â∞ùËØïÊç¢‰∏™Ê≠åÂêç / Ê≠åÊâãÂÜçÊêú‰∏ÄÊ¨°ÔΩû",
        statusInit: "Á≠âÂæÖÊêúÁ¥¢Ôºå‰Ω†ÂèØ‰ª•ËØïËØïËæìÂÖ•‚ÄúÂë®Êù∞‰º¶‚Äù„ÄÇ",
        statusPlaying: (title) => `ÂºÄÂßãÊí≠ÊîæÔºö${title}`,
        statusSearchError: "ÊêúÁ¥¢Êó∂Âá∫Áé∞ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ",
        statusSongError: "Âä†ËΩΩÊ≠åÊõ≤Êó∂Âá∫Áé∞ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ",
        playBtn: "‚ñ∂ Êí≠Êîæ",
        toggleLyricsBtn: "üéº ÊòæÁ§∫/ÈöêËóèÊ≠åËØç",
        downloadBtn: "‚¨áÔ∏è ‰∏ãËΩΩÈü≥‰πê",
        openOriginBtn: "üåê ÊâìÂºÄÂéüÈìæÊé•",
        stateIdle: "Èó≤ÁΩÆ‰∏≠",
        statePlaying: "Êí≠Êîæ‰∏≠",
        statePaused: "Â∑≤ÊöÇÂÅú",
        stateEnded: "Â∑≤ÁªìÊùü",
        openLyricsPrefix: "Â¶ÇÊûúÊ≠åËØçÊó†Ê≥ïÊ≠£Â∏∏ÊòæÁ§∫ÔºåÂèØ‰ª•ÊâìÂºÄÂéüÂßãÊ≠åËØçÊñá‰ª∂Ôºö",
        openLyricsText: "ÊâìÂºÄÂéüÂßãÊ≠åËØç",
        playlistTitle: "Êí≠ÊîæÂàóË°®",
        playlistEmpty: "Á©∫Á©∫Â¶Ç‰πü",
        playlistCount: (n) => `${n} È¶ñ`,
        shortcutsHint:
          "ÈîÆÁõòÂø´Êç∑ÈîÆÔºö\nSpaceÔºöÊí≠Êîæ/ÊöÇÂÅú  ‚Üê/‚ÜíÔºöÂø´ÈÄÄ/Âø´Ëøõ5Áßí\n‚Üë/‚ÜìÔºöÈü≥Èáè¬±5%  PÔºö‰∏ä‰∏ÄÈ¶ñ  NÔºö‰∏ã‰∏ÄÈ¶ñ  MÔºöÂàáÊç¢Êí≠ÊîæÊ®°Âºè",
        nowPlayingIdleTitle: "Á≠âÂæÖ‰Ω†ÁöÑÁÇπÊ≠å üéµ",
        nowPlayingIdleSinger: "Â∞èÁöÆÂç°ËØ¥ÔºöÂÖàÊù•‰∏ÄÈ¶ñËØïËØïÔºü",
        sourceLabelMigu: "Âí™ÂíïÈü≥‰πê",
        sourceLabelNetease: "ÁΩëÊòì‰∫ëÈü≥‰πê",
        sourceLabelBoth: (a, b) => `${a} + ${b}`,
        sourceFilterLabel: "ÊêúÁ¥¢Êù•Ê∫êÔºö",
        sourceFilterMigu: "Âí™ÂíïÈü≥‰πê",
        sourceFilterNetease: "ÁΩëÊòì‰∫ëÈü≥‰πê",
        sourceSummaryNone: "ÂΩìÂâçÊù•Ê∫êÔºöÊöÇÊó†",
        sourceSummaryMigu: (a) => `ÂΩìÂâçÊù•Ê∫êÔºö${a}`,
        sourceSummaryNetease: (b) => `ÂΩìÂâçÊù•Ê∫êÔºö${b}`,
        sourceSummaryBoth: (a, b) => `ÂΩìÂâçÊù•Ê∫êÔºö${a} + ${b}`,
        playModeSequence: "È°∫Â∫èÊí≠Êîæ",
        playModeLoopAll: "ÂàóË°®Âæ™ÁéØ",
        playModeSingle: "ÂçïÊõ≤Âæ™ÁéØ",
        playModeSequenceShort: "È°∫Â∫è",
        playModeLoopAllShort: "ÂàóË°®Âæ™ÁéØ",
        playModeSingleShort: "ÂçïÊõ≤"
      },
      en: {
        appTitle: "Pikachu Music Station",
        appSubtitle: "Search ¬∑ Play ¬∑ Shake with Pikachu",
        author: "Author: Zhenchao Jin + GPT5",
        searchPlaceholder: "Song / artist, e.g. Jay Chou",
        searchBtn: "Search",
        searchStatus: (q) => `Searching for ‚Äú${q}‚Äù ...`,
        searchResult: (n) => `Found ${n} results. Pick one to play!`,
        searchNoResult: "No results, try another keyword?",
        resultsInitialHint:
          "‚ö° Tip: search above\nFor example, type Jay Chou and click a song to play.",
        lyricsInitialPlaceholder:
          "üé§ Lyrics here and auto-highlight with playback.",
        lyricsLoading: "Loading lyrics...",
        lyricsParseFail: "Failed to parse lyrics (file may be empty).",
        lyricsNone: "No lyrics found for this song.",
        lyricsLoadFail:
          "Failed to load lyrics. Please try again later or open the raw file.",
        noResultPlaceholder:
          "No results for now. Try a different song / artist.",
        statusInit: 'Waiting for search. Try typing "Jay Chou".',
        statusPlaying: (title) => `Now playing: ${title}`,
        statusSearchError: "Error during search, please try again later.",
        statusSongError: "Error loading song, please try again later.",
        playBtn: "‚ñ∂ Play",
        toggleLyricsBtn: "üéº Show / Hide Lyrics",
        downloadBtn: "‚¨áÔ∏è Download",
        openOriginBtn: "üåê Source",
        stateIdle: "Idle",
        statePlaying: "Playing",
        statePaused: "Paused",
        stateEnded: "Ended",
        openLyricsPrefix:
          "If lyrics cannot be displayed, open the raw lyrics file:",
        openLyricsText: "Open raw lyrics",
        playlistTitle: "Playlist",
        playlistEmpty: "Empty",
        playlistCount: (n) => `${n} tracks`,
        shortcutsHint:
          "Keyboard shortcuts:\nSpace: play/pause  ‚Üê/‚Üí: -/+5s\n‚Üë/‚Üì: volume ¬±5%  P: prev  N: next  M: switch play mode",
        nowPlayingIdleTitle: "Waiting for your song üéµ",
        nowPlayingIdleSinger: "Pikachu says: pick something to play!",
        sourceLabelMigu: "MiGu Music",
        sourceLabelNetease: "NetEase Cloud",
        sourceLabelBoth: (a, b) => `${a} + ${b}`,
        sourceFilterLabel: "Sources:",
        sourceFilterMigu: "MiGu",
        sourceFilterNetease: "NetEase",
        sourceSummaryNone: "Sources: none",
        sourceSummaryMigu: (a) => `Sources: ${a}`,
        sourceSummaryNetease: (b) => `Sources: ${b}`,
        sourceSummaryBoth: (a, b) => `Sources: ${a} + ${b}`,
        playModeSequence: "Sequence",
        playModeLoopAll: "Loop All",
        playModeSingle: "Single Loop",
        playModeSequenceShort: "Seq",
        playModeLoopAllShort: "Loop",
        playModeSingleShort: "Single"
      }
    };

    let lastQuery = "";
    let lrcEntries = [];
    let currentLyricIndex = -1;
    let lyricsVisible = true;

    let playlist = [];
    let currentPlaylistPos = -1;

    let currentSongData = null;
    let currentSourceType = null;

    let vizAnimationId = null;
    if (vizCanvas && vizCtx) {
      const rect = vizCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      vizCanvas.width = rect.width * dpr;
      vizCanvas.height = rect.height * dpr;
      vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      startFakeVisualizer();
    }

    window.addEventListener("resize", () => {
      if (!vizCanvas || !vizCtx) return;
      const rect = vizCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      vizCanvas.width = rect.width * dpr;
      vizCanvas.height = rect.height * dpr;
      vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });

    function startFakeVisualizer() {
      if (!vizCanvas || !vizCtx) return;
      if (vizAnimationId) cancelAnimationFrame(vizAnimationId);

      let phase = 0;
      function draw() {
        vizAnimationId = requestAnimationFrame(draw);
        const rect = vizCanvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        if (
          vizCanvas.width !== rect.width * dpr ||
          vizCanvas.height !== rect.height * dpr
        ) {
          vizCanvas.width = rect.width * dpr;
          vizCanvas.height = rect.height * dpr;
          vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        const width = rect.width;
        const height = rect.height;
        vizCtx.clearRect(0, 0, width, height);

        const barCount = 40;
        const barWidth = width / barCount;
        const playing =
          !audioEl.paused && !audioEl.ended && audioEl.currentTime > 0;
        phase += playing ? 0.12 : 0.02;
        const base = playing ? 0.2 : 0.05;

        for (let i = 0; i < barCount; i++) {
          const wave = (Math.sin(phase + i * 0.4) + 1) / 2;
          const noise = Math.random() * 0.4;
          const v = base + (playing ? wave * 0.5 + noise * 0.2 : wave * 0.1);
          const barHeight = v * height;
          const x = i * barWidth;
          const y = height - barHeight;
          const alpha = 0.3 + 0.7 * v;

          vizCtx.fillStyle = "rgba(255,234,167," + alpha + ")";
          if (vizCtx.roundRect) {
            vizCtx.beginPath();
            vizCtx.roundRect(x + 1, y, barWidth - 2, barHeight, 4);
            vizCtx.fill();
          } else {
            vizCtx.fillRect(x + 1, y, barWidth - 2, barHeight);
          }
        }
      }
      draw();
    }

    function setStatus(text, kind) {
      globalStatusText.textContent = text;
      if (kind) globalStatusText.dataset.kind = kind;
    }

    function renderInitialResultsHint() {
      resultsEl.innerHTML = "";
      const hint = langStaticTexts[currentLang].resultsInitialHint;
      const div = document.createElement("div");
      div.className = "lyrics-placeholder";
      div.innerHTML = hint.replace(/\n/g, "<br/>");
      resultsEl.appendChild(div);
    }

    function showLyricsPlaceholder(text) {
      lyricsWrap.innerHTML = "";
      const div = document.createElement("div");
      div.className = "lyrics-placeholder";
      div.textContent = text;
      lyricsWrap.appendChild(div);
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    function showRawLyricsLink(url) {
      if (!lyricsLinkWrap) return;
      const t = langStaticTexts[currentLang];
      lyricsLinkWrap.innerHTML = "";
      const info = document.createElement("span");
      info.textContent = t.openLyricsPrefix;
      const link = document.createElement("a");
      link.href = url;
      link.target = "_blank";
      link.rel = "noopener";
      link.style.marginLeft = "4px";
      link.style.color = "#74b9ff";
      link.style.textDecoration = "underline";
      link.textContent = t.openLyricsText;
      lyricsLinkWrap.appendChild(info);
      lyricsLinkWrap.appendChild(link);
    }

    function updateSourceSummary() {
      const t = langStaticTexts[currentLang];
      const hasMigu = sourceMiguCheckbox ? sourceMiguCheckbox.checked : true;
      const hasNetease = sourceNeteaseCheckbox ? sourceNeteaseCheckbox.checked : true;
      let text;
      if (hasMigu && hasNetease) {
        text = t.sourceSummaryBoth(t.sourceLabelMigu, t.sourceLabelNetease);
      } else if (hasMigu) {
        text = t.sourceSummaryMigu(t.sourceLabelMigu);
      } else if (hasNetease) {
        text = t.sourceSummaryNetease(t.sourceLabelNetease);
      } else {
        text = t.sourceSummaryNone;
      }
      if (sourceSummaryEl) sourceSummaryEl.textContent = text;
    }

    function updatePlayModeLabel() {
      const t = langStaticTexts[currentLang];
      if (!playModeBtn) return;
      let text = "";
      if (playMode === PLAY_MODE_SEQUENCE) {
        text = "‚û° " + (t.playModeSequenceShort || t.playModeSequence);
      } else if (playMode === PLAY_MODE_LOOP_ALL) {
        text = "üîÅ " + (t.playModeLoopAllShort || t.playModeLoopAll);
      } else {
        text = "üîÇ " + (t.playModeSingleShort || t.playModeSingle);
      }
      playModeBtn.textContent = text;
    }

    function applyLanguage() {
      const t = langStaticTexts[currentLang];
      appTitleEl.textContent = t.appTitle;
      appSubtitleEl.textContent = t.appSubtitle;
      authorLineEl.textContent = t.author;
      searchInput.placeholder = t.searchPlaceholder;
      searchBtn.innerHTML = t.searchBtn + "<span>‚ö°</span>";
      toggleLyricsBtn.textContent = t.toggleLyricsBtn;
      downloadMusicBtn.textContent = t.downloadBtn;
      openOriginBtn.textContent = t.openOriginBtn;
      langToggleBtn.textContent = currentLang === "zh" ? "‰∏≠ / EN" : "EN / ‰∏≠";

      if (sourceFilterLabelEl) sourceFilterLabelEl.textContent = t.sourceFilterLabel;
      if (sourceFilterMiguTextEl) sourceFilterMiguTextEl.textContent = t.sourceFilterMigu;
      if (sourceFilterNeteaseTextEl) sourceFilterNeteaseTextEl.textContent = t.sourceFilterNetease;

      if (!currentSongData) {
        songTitleEl.textContent = t.nowPlayingIdleTitle;
        songSingerEl.textContent = t.nowPlayingIdleSinger;
      }

      if (audioEl.src) {
        if (!audioEl.paused && !audioEl.ended) {
          songStatusShort.textContent = t.statePlaying;
        } else if (audioEl.ended) {
          songStatusShort.textContent = t.stateEnded;
        } else {
          songStatusShort.textContent = t.statePaused;
        }
      } else {
        songStatusShort.textContent = t.stateIdle;
      }

      playlistTitleEl.textContent = t.playlistTitle;
      playlistCountEl.textContent = playlist.length
        ? t.playlistCount(playlist.length)
        : t.playlistEmpty;

      shortcutsHintEl.innerHTML = t.shortcutsHint.replace(/\n/g, "<br/>");

      updateSourceSummary();
      updatePlayModeLabel();

      if (!lrcEntries.length) {
        showLyricsPlaceholder(t.lyricsInitialPlaceholder);
      }
      if (!resultsEl.hasChildNodes()) {
        renderInitialResultsHint();
      }
      if (globalStatusText.dataset.kind === "init") {
        setStatus(t.statusInit, "init");
      }

      if (currentSourceType) {
        let labelText;
        if (currentSourceType === "netease") {
          labelText = t.sourceLabelNetease;
        } else if (currentSourceType === "both") {
          labelText = t.sourceLabelBoth(t.sourceLabelMigu, t.sourceLabelNetease);
        } else {
          labelText = t.sourceLabelMigu;
        }
        songSourceTextEl.textContent = labelText;
      }
    }

    function ensureAtLeastOneSource(changed) {
      if (!sourceMiguCheckbox || !sourceNeteaseCheckbox) return;
      const useMigu = sourceMiguCheckbox.checked;
      const useNetease = sourceNeteaseCheckbox.checked;
      if (!useMigu && !useNetease) {
        if (changed === "migu") {
          sourceNeteaseCheckbox.checked = true;
        } else {
          sourceMiguCheckbox.checked = true;
        }
      }
      updateSourceSummary();
    }

    langToggleBtn.addEventListener("click", () => {
      currentLang = currentLang === "zh" ? "en" : "zh";
      applyLanguage();
    });

    if (playModeBtn) {
      playModeBtn.addEventListener("click", () => {
        if (playMode === PLAY_MODE_SEQUENCE) {
          playMode = PLAY_MODE_LOOP_ALL;
        } else if (playMode === PLAY_MODE_LOOP_ALL) {
          playMode = PLAY_MODE_SINGLE;
        } else {
          playMode = PLAY_MODE_SEQUENCE;
        }
        updatePlayModeLabel();
      });
    }

    if (sourceMiguCheckbox) {
      sourceMiguCheckbox.addEventListener("change", () =>
        ensureAtLeastOneSource("migu")
      );
    }
    if (sourceNeteaseCheckbox) {
      sourceNeteaseCheckbox.addEventListener("change", () =>
        ensureAtLeastOneSource("netease")
      );
    }

    searchForm.addEventListener("submit", function (e) {
      e.preventDefault();
      const q = searchInput.value.trim();
      if (!q) return;
      lastQuery = q;
      currentLyricIndex = -1;
      lrcEntries = [];
      const t = langStaticTexts[currentLang];
      setStatus(t.searchStatus(q));
      searchSongs(q);
    });

    async function searchSongs(query) {
      const t = langStaticTexts[currentLang];
      try {
        let useMigu = !sourceMiguCheckbox || sourceMiguCheckbox.checked;
        let useNetease = !sourceNeteaseCheckbox || sourceNeteaseCheckbox.checked;

        // Èò≤Ê≠¢‰∏§‰∏™ÈÉΩË¢´ÂèñÊ∂àÔºåÂº∫Âà∂ÊÅ¢Â§ç‰∏∫‰∏§‰∏™ÈÉΩÈÄâ
        if (!useMigu && !useNetease) {
          useMigu = true;
          useNetease = true;
          if (sourceMiguCheckbox) sourceMiguCheckbox.checked = true;
          if (sourceNeteaseCheckbox) sourceNeteaseCheckbox.checked = true;
        }

        const miguUrl =
          API_MIGU +
          "?msg=" +
          encodeURIComponent(query) +
          "&type=text";

        const neteaseUrl =
          API_NETEASE_SEARCH +
          "?type=json&msg=" +
          encodeURIComponent(query) +
          "&num=" +
          NETEASE_LIMIT +
          "&n=";

        const miguPromise = useMigu
          ? fetch(miguUrl).then((r) => r.text()).catch(() => null)
          : Promise.resolve(null);
        const neteasePromise = useNetease
          ? fetch(neteaseUrl).then((r) => r.json()).catch(() => null)
          : Promise.resolve(null);

        const [miguText, neteaseJson] = await Promise.all([
          miguPromise,
          neteasePromise
        ]);

        let miguListRaw = [];
        if (miguText) {
          miguListRaw = parseSearchResultText(miguText);
        }

        let neteaseListRaw = [];
        if (neteaseJson && neteaseJson.code === 200 && Array.isArray(neteaseJson.data)) {
          neteaseListRaw = neteaseJson.data.map((it) => ({
            index: it.n,
            title: it.title,
            singer: it.singer,
            songid: it.songid
          }));
        }

        const merged = [];
        let globalIndex = 1;

        if (useMigu) {
          miguListRaw.forEach((it) => {
            merged.push({
              globalIndex: globalIndex++,
              title: it.title,
              singer: it.singer,
              source: "migu",
              apiIndex: it.index
            });
          });
        }

        if (useNetease) {
          neteaseListRaw.forEach((it) => {
            merged.push({
              globalIndex: globalIndex++,
              title: it.title,
              singer: it.singer,
              source: "netease",
              apiIndex: it.index,
              songid: it.songid
            });
          });
        }

        updateSourceSummary();
        renderResultList(merged, query);

        if (!merged.length) {
          setStatus(t.searchNoResult);
        } else {
          setStatus(t.searchResult(merged.length));
        }
      } catch (err) {
        console.error(err);
        renderResultList([], query);
        setStatus(t.statusSearchError);
      }
    }

    function parseSearchResultText(text) {
      const lines = text
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l && /^\d+[\.\„ÄÅ]/.test(l));

      const list = [];
      for (const line of lines) {
        const parts = line.split(" -- ");
        if (parts.length < 2) continue;
        const left = parts[0].trim();
        const singer = parts.slice(1).join(" -- ").trim();

        const idxMatch = left.match(/^(\d+)[\.\„ÄÅ](.+)$/);
        if (!idxMatch) continue;

        const index = parseInt(idxMatch[1], 10);
        const title = idxMatch[2].trim();
        list.push({ index, title, singer });
      }
      return list;
    }

    function renderResultList(list, queryForItems) {
      const t = langStaticTexts[currentLang];
      resultsEl.innerHTML = "";
      if (!list.length) {
        const div = document.createElement("div");
        div.className = "lyrics-placeholder";
        div.textContent = t.noResultPlaceholder;
        resultsEl.appendChild(div);
        return;
      }

      const newPlaylist = [];

      list.forEach((item) => {
        const row = document.createElement("div");
        row.className = "result-item";
        row.dataset.index = String(item.globalIndex);

        const main = document.createElement("div");
        main.className = "result-main";

        const idxEl = document.createElement("div");
        idxEl.className = "result-index";
        idxEl.textContent = item.globalIndex + ".";

        const titleEl = document.createElement("div");
        titleEl.className = "result-title";
        titleEl.textContent = item.title;

        const singerEl = document.createElement("div");
        singerEl.className = "result-singer";
        singerEl.textContent = "‚Äî " + item.singer;

        const chip = document.createElement("span");
        const isNetease = item.source === "netease";
        chip.className =
          "source-chip " + (isNetease ? "source-chip-netease" : "source-chip-migu");
        const chipDot = document.createElement("span");
        chipDot.className = "source-chip-dot";
        const chipText = document.createElement("span");
        chipText.textContent = isNetease
          ? t.sourceLabelNetease
          : t.sourceLabelMigu;
        chip.appendChild(chipDot);
        chip.appendChild(chipText);

        main.appendChild(idxEl);
        main.appendChild(titleEl);
        main.appendChild(singerEl);
        main.appendChild(chip);

        const actions = document.createElement("div");
        actions.className = "result-actions";

        const payload = {
          query: queryForItems,
          source: item.source,
          apiIndex: item.apiIndex,
          title: item.title,
          singer: item.singer,
          songid: item.songid || null
        };

        newPlaylist.push(payload);

        const playBtn = document.createElement("button");
        playBtn.type = "button";
        playBtn.className = "pill-btn";
        playBtn.innerHTML = t.playBtn;
        playBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          playSong(payload, { fromSearch: true, globalIndex: item.globalIndex });
        });

        actions.appendChild(playBtn);
        row.appendChild(main);
        row.appendChild(actions);

        row.addEventListener("click", () => {
          playSong(payload, { fromSearch: true, globalIndex: item.globalIndex });
        });

        resultsEl.appendChild(row);
      });

      playlist = newPlaylist;
      currentPlaylistPos = -1;
      renderPlaylist();
    }

    function highlightActiveResult(globalIndex) {
      const rows = resultsEl.querySelectorAll(".result-item");
      rows.forEach((row) => {
        row.classList.toggle(
          "active",
          globalIndex != null && row.dataset.index === String(globalIndex)
        );
      });
    }

    function renderPlaylist() {
      const t = langStaticTexts[currentLang];
      playlistListEl.innerHTML = "";
      playlist.forEach((p, idx) => {
        const row = document.createElement("div");
        row.className = "playlist-item";
        if (idx === currentPlaylistPos) row.classList.add("active");

        const idxEl = document.createElement("div");
        idxEl.className = "playlist-index";
        idxEl.textContent = idx + 1;

        const main = document.createElement("div");
        main.className = "playlist-main";

        const titleEl = document.createElement("div");
        titleEl.className = "playlist-title";
        titleEl.textContent = p.title || "Unknown";

        const singerEl = document.createElement("div");
        singerEl.className = "playlist-singer";
        singerEl.textContent = p.singer || "";

        main.appendChild(titleEl);
        main.appendChild(singerEl);

        const badge = document.createElement("div");
        badge.className = "playlist-badge";
        badge.textContent = idx === currentPlaylistPos ? "‚ñ∂" : "";

        row.appendChild(idxEl);
        row.appendChild(main);
        row.appendChild(badge);

        row.addEventListener("click", () => {
          playFromPlaylist(idx);
        });

        playlistListEl.appendChild(row);
      });

      playlistCountEl.textContent = playlist.length
        ? t.playlistCount(playlist.length)
        : t.playlistEmpty;
    }

    async function fetchSongDetail(item) {
      if (item.source === "netease") {
        if (!item.songid) {
          throw new Error("Missing NetEase songid");
        }

        const url =
          API_NETEASE_DETAIL +
          "?id=" +
          encodeURIComponent(item.songid) +
          "&type=json&level=lossless";

        const resp = await fetch(url);
        const json = await resp.json();

        if (json.code !== 200 || !json.data) {
          throw new Error(json.msg || "Netease detail error");
        }

        const raw = json.data || {};

        const data = {
          title: raw.title || raw.name || item.title,
          singer: raw.singer || raw.artist || raw.artists || item.singer,
          cover: raw.cover || raw.pic || raw.picUrl || null,
          music_url: raw.url || raw.music_url || raw.music || raw.play_url || null,
          lrc_url: raw.lrc_url || raw.lrc || null,
          lrc: raw.lyric || raw.lrc_text || null,
          link: raw.page || raw.link || raw.page_url || null
        };

        data._source = "netease";
        return data;
      } else {
        const url =
          API_MIGU +
          "?msg=" +
          encodeURIComponent(item.query) +
          "&type=json&n=" +
          item.apiIndex;
        const resp = await fetch(url);
        const json = await resp.json();
        if (json.code !== 200 || !json.data) {
          throw new Error(json.msg || "Migu error");
        }
        const data = json.data;
        data._source = "migu";
        return data;
      }
    }

    async function playSong(item, options) {
      const opts = options || {};
      const t = langStaticTexts[currentLang];
      lastQuery = item.query;

      let pos = playlist.findIndex((p) => {
        if (p.source !== item.source) return false;
        if (item.source === "netease" && item.songid && p.songid) {
          return p.songid === item.songid;
        }
        return p.query === item.query && p.apiIndex === item.apiIndex;
      });

      if (pos === -1) {
        playlist.push(item);
        pos = playlist.length - 1;
      }
      currentPlaylistPos = pos;
      renderPlaylist();

      if (opts.fromSearch && opts.globalIndex != null) {
        highlightActiveResult(opts.globalIndex);
      }

      setStatus(t.searchStatus(item.query));
      try {
        let data = item.data;
        if (!data) {
          data = await fetchSongDetail(item);
          item.data = data;
          playlist[pos].data = data;
        }

        updateNowPlaying(data);
        setStatus(t.statusPlaying(data.title));
        audioEl.play().catch(() => {});
        await loadLyricsForData(data);
      } catch (err) {
        console.error(err);
        setStatus(t.statusSongError);
      }
    }

    function playFromPlaylist(idx) {
      if (idx < 0 || idx >= playlist.length) return;
      currentPlaylistPos = idx;
      renderPlaylist();
      const item = playlist[idx];
      playSong(item, { fromPlaylist: true });
    }

    function playNextInPlaylist(fromEnded = false) {
      if (!playlist.length) return;

      if (fromEnded && playMode === PLAY_MODE_SINGLE) {
        if (currentPlaylistPos >= 0 && currentPlaylistPos < playlist.length) {
          playFromPlaylist(currentPlaylistPos);
        }
        return;
      }

      let next = currentPlaylistPos + 1;

      if (next >= playlist.length) {
        if (fromEnded && playMode === PLAY_MODE_LOOP_ALL) {
          next = 0;
        } else {
          return;
        }
      }
      playFromPlaylist(next);
    }

    function playPrevInPlaylist() {
      if (!playlist.length) return;
      let prev = currentPlaylistPos - 1;
      if (prev < 0) return;
      playFromPlaylist(prev);
    }

    function updateNowPlaying(data) {
      const t = langStaticTexts[currentLang];
      currentSongData = data;

      songTitleEl.textContent = data.title || t.nowPlayingIdleTitle;
      songSingerEl.textContent = data.singer || t.nowPlayingIdleSinger;

      songStatusShort.textContent = t.statePlaying;

      const cover = data.cover || data.pic || data.picUrl;
      if (cover) coverImg.src = cover;

      const musicUrl = data.music_url || data.url || data.music || data.play_url;
      if (musicUrl) {
        audioEl.src = musicUrl;
        downloadMusicBtn.href = musicUrl;
        downloadMusicBtn.download = (data.title || "music") + ".mp3";
      } else {
        audioEl.removeAttribute("src");
        downloadMusicBtn.href = "#";
      }

      const pageLink = data.link || data.page || data.page_url;
      if (pageLink) openOriginBtn.href = pageLink;
      else openOriginBtn.href = "#";

      const type = data._source || data.source || "migu";
      currentSourceType = type;

      let labelText = "";
      let dotClass = "source-migu";

      const t2 = langStaticTexts[currentLang];
      if (type === "netease") {
        labelText = t2.sourceLabelNetease;
        dotClass = "source-netease";
      } else if (type === "both") {
        labelText = t2.sourceLabelBoth(t2.sourceLabelMigu, t2.sourceLabelNetease);
        dotClass = "source-mixed";
      } else {
        labelText = t2.sourceLabelMigu;
        dotClass = "source-migu";
      }

      songSourceTextEl.textContent = labelText;
      const dotEl = songSourceTag.querySelector(".source-dot");
      if (dotEl) dotEl.className = "source-dot " + dotClass;
      songSourceTag.style.display = "inline-flex";

      lrcEntries = [];
      currentLyricIndex = -1;
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    async function loadLyricsForData(data) {
      const t = langStaticTexts[currentLang];
      if (data.lrc_url) {
        showLyricsPlaceholder(t.lyricsLoading);
        await loadLyricsFromUrl(data.lrc_url);
      } else if (data.lrc) {
        showLyricsPlaceholder(t.lyricsLoading);
        loadLyricsFromText(data.lrc);
      } else {
        showLyricsPlaceholder(t.lyricsNone);
      }
    }

    async function loadLyricsFromUrl(url) {
      const t = langStaticTexts[currentLang];
      try {
        const resp = await fetch(url);
        const text = await resp.text();
        const entries = parseLRC(text);
        lrcEntries = entries;
        currentLyricIndex = -1;
        if (!entries.length) {
          showLyricsPlaceholder(t.lyricsParseFail);
          showRawLyricsLink(url);
          return;
        }
        renderLyrics(entries);
      } catch (err) {
        console.error(err);
        showLyricsPlaceholder(t.lyricsLoadFail);
        showRawLyricsLink(url);
      }
    }

    function loadLyricsFromText(raw) {
      const t = langStaticTexts[currentLang];
      const entries = parseLRC(raw);
      lrcEntries = entries;
      currentLyricIndex = -1;
      if (!entries.length) {
        showLyricsPlaceholder(t.lyricsParseFail);
        return;
      }
      renderLyrics(entries);
    }

    function parseLRC(raw) {
      const lines = raw.split("\n");
      const result = [];
      const timeTagRegex = /\[(\d+):(\d+(?:\.\d+)?)\]/g;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        let match;
        const timeTags = [];
        while ((match = timeTagRegex.exec(trimmed))) {
          const min = parseInt(match[1], 10);
          const sec = parseFloat(match[2]);
          const time = min * 60 + sec;
          timeTags.push(time);
        }

        const text = trimmed.replace(timeTagRegex, "").trim();
        if (!timeTags.length || !text) continue;

        timeTags.forEach((t) => {
          result.push({ time: t, text: text });
        });
      }

      result.sort((a, b) => a.time - b.time);
      return result;
    }

    function renderLyrics(entries) {
      lyricsWrap.innerHTML = "";
      entries.forEach((entry, idx) => {
        const lineEl = document.createElement("div");
        lineEl.className = "lyric-line";
        lineEl.dataset.index = String(idx);
        lineEl.dataset.time = String(entry.time);
        lineEl.textContent = entry.text;
        lyricsWrap.appendChild(lineEl);
      });
      if (lyricsLinkWrap) lyricsLinkWrap.innerHTML = "";
    }

    audioEl.addEventListener("timeupdate", () => {
      if (!lrcEntries.length) return;
      const currentTime = audioEl.currentTime;
      let idx = currentLyricIndex;
      if (idx < 0 || currentTime < lrcEntries[idx].time) idx = 0;
      while (
        idx + 1 < lrcEntries.length &&
        lrcEntries[idx + 1].time <= currentTime + 0.15
      ) {
        idx++;
      }
      if (idx !== currentLyricIndex) {
        currentLyricIndex = idx;
        updateActiveLyricLine(idx);
      }
    });

    function updateActiveLyricLine(idx) {
      const lines = lyricsWrap.querySelectorAll(".lyric-line");
      lines.forEach((el) => {
        const lineIdx = parseInt(el.dataset.index, 10);
        el.classList.toggle("active", lineIdx === idx);
      });
      const activeEl = lyricsWrap.querySelector(
        '.lyric-line[data-index="' + idx + '"]'
      );
      if (activeEl) {
        activeEl.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    audioEl.addEventListener("play", () => {
      const t = langStaticTexts[currentLang];
      songStatusShort.textContent = t.statePlaying;
    });

    audioEl.addEventListener("pause", () => {
      const t = langStaticTexts[currentLang];
      if (audioEl.ended) {
        songStatusShort.textContent = t.stateEnded;
      } else {
        songStatusShort.textContent = t.statePaused;
      }
    });

    audioEl.addEventListener("ended", () => {
      const t = langStaticTexts[currentLang];
      songStatusShort.textContent = t.stateEnded;
      // ÁªìÊùüÊó∂Ê†πÊçÆÊí≠ÊîæÊ®°ÂºèËá™Âä®Ë∑≥ËΩ¨
      playNextInPlaylist(true);
    });

    toggleLyricsBtn.addEventListener("click", () => {
      lyricsVisible = !lyricsVisible;
      lyricsWrap.style.display = lyricsVisible ? "block" : "none";
      if (lyricsLinkWrap)
        lyricsLinkWrap.style.display = lyricsVisible ? "block" : "none";
    });

    function togglePlayPause() {
      if (!audioEl.src) return;
      if (audioEl.paused) audioEl.play().catch(() => {});
      else audioEl.pause();
    }

    window.addEventListener("keydown", (e) => {
      const tag = (e.target.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || e.target.isContentEditable)
        return;

      if (e.code === "Space") {
        e.preventDefault();
        togglePlayPause();
      } else if (e.code === "ArrowRight") {
        if (!isNaN(audioEl.duration)) {
          audioEl.currentTime = Math.min(
            audioEl.duration,
            audioEl.currentTime + 5
          );
        }
      } else if (e.code === "ArrowLeft") {
        audioEl.currentTime = Math.max(0, audioEl.currentTime - 5);
      } else if (e.code === "ArrowUp") {
        e.preventDefault();
        audioEl.volume = Math.min(1, audioEl.volume + 0.05);
      } else if (e.code === "ArrowDown") {
        e.preventDefault();
        audioEl.volume = Math.max(0, audioEl.volume - 0.05);
      } else if (e.key === "n" || e.key === "N") {
        playNextInPlaylist(false);
      } else if (e.key === "p" || e.key === "P") {
        playPrevInPlaylist();
      } else if (e.key === "m" || e.key === "M") {
        if (playModeBtn) playModeBtn.click();
      }
    });

    // ÂàùÂßãÁä∂ÊÄÅ
    renderInitialResultsHint();
    showLyricsPlaceholder(langStaticTexts[currentLang].lyricsInitialPlaceholder);
    setStatus(langStaticTexts[currentLang].statusInit, "init");
    updateSourceSummary();
    applyLanguage();
  })();
  </script>
</body>
</html>
